<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Device Management Functions</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="μT-Kernel 3.0 Specification"
HREF="index.html"><LINK
REL="UP"
TITLE="μT-Kernel/SM Functions"
HREF="utk_sm_functions.html"><LINK
REL="PREVIOUS"
TITLE="μT-Kernel/SM Functions"
HREF="utk_sm_functions.html"><LINK
REL="NEXT"
TITLE="Interrupt Management Functions"
HREF="interrupt_management_functions_sm.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>μT-Kernel 3.0 Specification</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="utk_sm_functions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>μT-Kernel/SM Functions</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="interrupt_management_functions_sm.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="device_management_functions"
>Device Management Functions</A
></H1
><P
>Device management functions manage device drivers running on μT-Kernel.</P
><P
>A device driver is a program that is implemented independent from μT-Kernel itself to control a hardware device or perform I/O processing with the hardware device. Since the difference of specifications among individual devices is absorbed by the device driver when an application or middleware operates a device or performs I/O processing with the device via the device driver, the application or middleware can enhance its hardware independence and compatibility.</P
><P
>Device management functions include a function to define a device driver, or to register the device driver to μT-Kernel, and a function to use the registered device driver from an application or middleware.</P
><P
>While this registration of device drivers is mostly performed in the initialization at system startup, it can also be performed dynamically during the normal operation of the system. A device driver is registered in the device registration information (<CODE
CLASS="varname"
>ddev</CODE
>) that is one of parameters for the API, <A
HREF="device_management_functions.html#tk_def_dev"
>tk_def_dev</A
>, by specifying the set of functions (driver processing functions) of a program that actually implements device driver. These functions include the open function (<A
HREF="device_management_functions.html#openfn"
>openfn</A
>) that is called when a device is opened, the execute function (<A
HREF="device_management_functions.html#execfn"
>execfn</A
>) that is called when read or write processing starts, wait-for-completion function (<A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>) that waits for completion of read or write processing, etc. The actual operation of a device or I/O processing with the devices are performed in these driver processing functions.</P
><P
>As these driver execute functions are executed at protection level 0 as quasi-task portion, they can also access hardware directly. I/O processing with a device may be performed directly in these driver execute functions or may be performed in another task that runs based on the request from one of these driver execute functions. The specification of parameters, etc. when these driver execute functions are called is defined as part of the device driver interface. The device driver interface is an interface between a device driver and the μT-Kernel device management functions.</P
><P
>When a device driver program is implemented, it is recommended to separate three layers of interface, logical, and physical layers carefully in order to enhance their maintainability and portability. The interface layer is responsible for implementing an interface between the μT-Kernel device management functions and a device driver. The logical layer is responsible for performing a common processing according to the type of device. The physical layer is responsible for performing an operation dependent on the actual hardware or control chip. The interface specification, however, among the interface layer, logical layer, and physical layer is not specified in the μT-Kernel, so that the actual layer separation can be implemented appropriately in each device driver. Programs that process the interface layer may be provided as libraries since there are many common processing steps that are independent of individual devices in the physical layer.</P
><P
>APIs are provided such as open (<A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
>), close (<A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
>), read (<A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>), write (<A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>), etc. to use the registered device driver from an application or middleware. The specification of these APIs is called an application interface. For example, when an application executes <A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
> to open a device, the μT-Kernel calls the open function (<A
HREF="device_management_functions.html#openfn"
>openfn</A
>) for the corresponding device driver to request the device open processing.</P
><P
>The positioning and structure of μT-Kernel device management functions are shown in <A
HREF="device_management_functions.html#figure_basic_concepts_device_management"
>Figure 1</A
>.</P
><DIV
CLASS="figure"
><A
NAME="figure_basic_concepts_device_management"
></A
><P
><B
>Figure 1. Device Management Functions</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="images/f_39s.png"></P
></DIV
></DIV
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="MIDDLE"
><B
>Additional Notes</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The device drivers have common features with the subsystems as being implemented independent from μT-Kernel itself and also being a system program to add or extend functions for μT-Kernel. Additionally, both are also same in that they operate at protection level 0, and can access a hardware. Notable differences between the two, is that while API for calling a device driver is limited to using open/close and read/write type, API for calling a subsystem can be defined without any restriction.</P
><P
>Though μT-Kernel device drivers managed by device management functions are assumed to be drivers for physical devices or hardware, they are not necessarily required to handle real physical devices or hardware. Also, system program for operating a device could be implemented as a subsystem rather than a device driver if it is not compatible with open/close or read/write type APIs.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="common_device_driver"
>Common Notes Related to Device Drivers</A
></H2
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="basic_concepts_device_management"
>Basic Concepts</A
></H3
><P
>In addition to a physical device that represents a device as a physical hardware, there is a logical device that represents a perceived unit of a device from the viewpoint of software.</P
><P
>Although both devices match for most devices, when partitions were created on a hard disk or any other storage type device (SD card, USB storage, etc.), entire device represents a physical device and each partition represents a logical device.</P
><P
>The physical devices of same type are identified by "unit" while logical devices in one physical device are identified by "subunit." For example, the information that distinguishes the first hard disk from the second is called "unit," and the information that distinguishes the first partition from the second within that first hard disk is called "subunit."</P
><P
>The data definitions used in device management functions are explained in the subsequent subsections.</P
><P
>In the following description, the references and mentions are made to particular types of devices and their names. These are not meant to be the part of μT-Kernel specification, but rather are offered as a common guideline for defining device driver specifications. Each device driver does not have to implement all the functions described here. However, each driver should be designed so that their behavior is compliant with the description in the following if applicable.</P
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN18966"
>Device Name (UB* type)</A
></H4
><P
>A device name is a string of up to eight characters that is given to each device. US-ASCII is the used character code. It consists of the following elements:</P
><PRE
CLASS="programlisting"
>&#13;#define L_DEVNM         8       /* Device name length */
</PRE
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Type</DT
><DD
><P
>Name indicating the device type</P
><P
>Characters a to z and A to Z can be used.</P
></DD
><DT
>Unit</DT
><DD
><P
>One letter indicating a physical device</P
><P
>Each unit is assigned a letter from a to z in order starting from a.</P
></DD
><DT
>Subunit</DT
><DD
><P
>One to three digits indicating a logical device</P
><P
>Each subunit is assigned a number from 0 to 254 in order starting from 0.</P
></DD
></DL
></DIV
><P
>Device names take the format of type + unit + subunit. Some devices may not have a unit or subunit, in which case the corresponding field is omitted.</P
><P
>The subunit is usually used to distinguish partitions in a hard disk. In other devices also, it can be used to create multiple logical devices in one physical device.</P
><P
>A name consisting of type + unit is called a physical device name. A name consisting of type + unit + subunit is called a logical device name. If there is no subunit, the physical device name and logical device name are identical. The term "device name" by itself means the logical device name.</P
><DIV
CLASS="example"
><A
NAME="AEN18989"
></A
><P
><B
>Example 1. Example of Device Name</B
></P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN18991"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Device name</TH
><TH
>Target device</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
>hda</TD
><TD
>Hard disk (entire disk)</TD
></TR
><TR
><TD
>hda0</TD
><TD
>Hard disk (1st partition)</TD
></TR
><TR
><TD
>fda</TD
><TD
>Floppy disk</TD
></TR
><TR
><TD
>rsa</TD
><TD
>Serial port</TD
></TR
><TR
><TD
>kbpd</TD
><TD
>Keyboard/pointing device</TD
></TR
><TR
><TD
>fla</TD
><TD
>Flash memory</TD
></TR
><TR
><TD
>neta</TD
><TD
>Network</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19019"
>Device ID (ID type)</A
></H4
><P
>By registering a device (device driver) with μT-Kernel/SM, a device ID (&#62; 0) is assigned to the device (physical device name). Device IDs are assigned to each physical device. The device ID of a logical device consists of the device ID assigned to the physical device to which is appended the subunit number + 1 (1 to 255).</P
><PRE
CLASS="synopsis"
>&#13;devid: The device ID assigned at device registration

devid           Physical device
devid + n+1     The nth subunit (logical device)
</PRE
><DIV
CLASS="example"
><A
NAME="AEN19023"
></A
><P
><B
>Example 2. Example of Device ID</B
></P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19025"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>Device name</TH
><TH
>Device ID</TH
><TH
>Summary description</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
>hda</TD
><TD
>devid</TD
><TD
>Hard disk (entire disk)</TD
></TR
><TR
><TD
>hda0</TD
><TD
>devid + 1</TD
><TD
>1st partition of hard disk</TD
></TR
><TR
><TD
>hda1</TD
><TD
>devid + 2</TD
><TD
>2nd partition of hard disk</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19045"
>Device Attribute (ATR type)</A
></H4
><P
>Device attributes are defined in order to represent a feature for each device and classify a device for each type. Device attributes should be specified when registering a device driver.</P
><P
>The specification method of device attributes is as follows:</P
><PRE
CLASS="synopsis"
>&#13;IIII IIII IIII IIII PRxx xxxx KKKK KKKK
</PRE
><P
>The high 16 bits are device-dependent attributes defined for each device. The low 16 bits are standard attributes defined as follows.
<PRE
CLASS="programlisting"
>&#13;#define TD_PROTECT      0x8000  /* P: Write protected */
#define TD_REMOVABLE    0x4000  /* R: removable media */

#define TD_DEVKIND      0x00ff  /* K: device/media kind */
#define TD_DEVTYPE      0x00f0  /*    device type */

                                /* device type */
#define TDK_UNDEF       0x0000  /* undefined/unknown */
#define TDK_DISK        0x0010  /* disk device */
</PRE
>

</P
><P
>Within the realm of μT-Kernel, the device type other than disk type is not defined. Defining the device type other than disk type does not affect the behavior of μT-Kernel. Other devices are assigned to undefined type (<TT
CLASS="literal"
>TDK_UNDEF</TT
>).</P
><P
>For the disk device, the disk kinds are additionally defined. The typical disk kinds are as follows:
<PRE
CLASS="programlisting"
>&#13; /* disk kind */
#define TDK_DISK_UNDEF  0x0010  /* miscellaneous disk */
#define TDK_DISK_RAM    0x0011  /* RAM disk (used as main memory) */
#define TDK_DISK_ROM    0x0012  /* ROM disk (used as main memory) */
#define TDK_DISK_FLA    0x0013  /* Flash ROM or other silicon disk */
#define TDK_DISK_FD     0x0014  /* Floppy disk */
#define TDK_DISK_HD     0x0015  /* hard disk */
#define TDK_DISK_CDROM  0x0016  /* CD-ROM */
</PRE
>

</P
><P
>The definition of disk kinds does not affect the μT-Kernel behavior. These definitions are used only when they are required in a device driver or an application. For example, when an application must change its processing according to the kind of devices or media, the disk kind information is used. Devices or media that do not need such distinctions do not have to be assigned a device type.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19057"
>Device Descriptor (ID type)</A
></H4
><P
>A device descriptor is an identifier used to access a device.</P
><P
>The device descriptor is assigned a positive value (&#62; 0) by the μT-Kernel/SM when a device is opened.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19061"
>Request ID (ID type)</A
></H4
><P
>When an I/O request is made to a device, a request ID (&#62; 0) is assigned identifying the request. This ID can be used to wait for I/O completion.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19064"
>Data Number (W type, D type)</A
></H4
><P
>Data input/output from/to device is specified by a data number. Data is roughly classified into device-specific data and attribute data.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Device-specific data: Data number ≧ 0</DT
><DD
><P
>As device-specific data, the data numbers are defined separately for each device.<DIV
CLASS="example"
><A
NAME="AEN19072"
></A
><P
><B
>Example 3. Example of Device-specific Data</B
></P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19074"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>device</TH
><TH
>Data number</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
>Disk</TD
><TD
>Data number = physical block number</TD
></TR
><TR
><TD
>Serial port</TD
><TD
>Data number = 0 only</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
></P
></DD
><DT
>Attribute data: Data number &#60; 0</DT
><DD
><P
>Attribute data specifies driver or device state acquisition and setting modes, and special functions, etc.</P
><P
>Data numbers common to devices are defined, but device-dependent attribute data can also be defined. For more details, see <A
HREF="device_management_functions.html#attribute_data_device_management"
>the Section called <I
>Attribute Data</I
></A
>.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="attribute_data_device_management"
>Attribute Data</A
></H3
><P
>Attribute data are classified broadly into the following three types of data.<P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Common attributes</DT
><DD
><P
>Attributes defined in common for all devices (device drivers).</P
></DD
><DT
>Device kind attributes</DT
><DD
><P
>Attributes defined in common for devices (device drivers) of the same kind.</P
></DD
><DT
>Device-specific attributes</DT
><DD
><P
>Attributes defined individually for each device (device driver).</P
></DD
></DL
></DIV
></P
><P
>Device kind attributes and device-specific attributes are out of scope of this specification and defined in device driver's specifications. Only the common attributes are defined here.</P
><P
>Common attributes are assigned attribute data numbers in the range from -1 to -99. While common attribute data numbers are the same for all devices, not all devices necessarily support all the common attributes. If an unsupported data number is specified, error code <SPAN
CLASS="errorname"
>E_PAR</SPAN
> is returned.</P
><P
>The definition of common attributes is as follows:
<PRE
CLASS="programlisting"
>&#13;#define TDN_EVENT       (-1)    /* RW: event notification message buffer ID */
#define TDN_DISKINFO    (-2)    /* R: disk information */
#define TDN_DISPSPEC    (-3)    /* reserved */
#define TDN_PCMCIAINFO  (-4)    /* reserved */
#define TDN_DISKINFO_D  (-5)    /* R: disk information (64-bit device) */
</PRE
>

            <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>RW: read (<A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>)/write (<A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>) enabled</TD
></TR
><TR
><TD
>R-: read (<A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>) only</TD
></TR
></TBODY
></TABLE
><P
></P
>
            <P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
>TDN_EVENT</TT
></DT
><DD
><P
>Event notification message buffer ID</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19126"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="67%"><TBODY
VALIGN="top"
><TR
><TD
>Data type</TD
><TD
>ID</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>The ID of the message buffer used for device event notification.</P
><P
>As a device is registered by <A
HREF="device_management_functions.html#tk_def_dev"
>tk_def_dev</A
> when a device driver is started and the system default event notification message buffer ID (<CODE
CLASS="varname"
>evtmbfid</CODE
>) is returned as this API return parameter, the value is held in the device driver and is used as the initial value of this attribute data.</P
><P
>If 0 is set, device events are not notified. For device event notification, see <A
HREF="device_management_functions.html#device_event_notification_device_management"
>the Section called <I
>Device Event Notification</I
></A
>.</P
></DD
><DT
><TT
CLASS="literal"
>TDN_DISKINFO</TT
></DT
><DD
><P
>32-bit device and disk information</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19145"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="67%"><TBODY
VALIGN="top"
><TR
><TD
>Data type</TD
><TD
>DiskInfo</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><PRE
CLASS="programlisting"
>&#13;typedef enum {
        DiskFmt_STD     = 0,            /* standard (HD, etc.) */
        DiskFmt_CDROM   = 4             /* CD-ROM 640MB */
} DiskFormat;
</PRE
><PRE
CLASS="programlisting"
>&#13;typedef struct {
        DiskFormat format;              /* format */
        UW      protect:1;              /* protected status */
        UW      removable:1;            /* removable */
        UW      rsv:30;                 /* reserved (always 0) */
        W       blocksize;              /* block size in bytes */
        W       blockcont;              /* total block count */
} DiskInfo;
</PRE
><P
>For definition of DiskFormat other than the above description, see the specification related to device drivers.</P
></DD
><DT
><TT
CLASS="literal"
>TDN_DISPSPEC</TT
></DT
><DD
><P
>Display Device Specification</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19161"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="67%"><TBODY
VALIGN="top"
><TR
><TD
>Data type</TD
><TD
>DEV_SPEC</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>For the definition of DEV_SPEC, see the specification related to device drivers.</P
></DD
><DT
><TT
CLASS="literal"
>TDN_DISKINFO_D</TT
></DT
><DD
><P
>64-bit device and disk information</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19175"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="67%"><TBODY
VALIGN="top"
><TR
><TD
>Data type</TD
><TD
>DiskInfo_D</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><PRE
CLASS="programlisting"
>&#13;typedef struct diskinfo_d {
        DiskFormat format;      /* format */
        BOOL    protect:1;      /* protected status */
        BOOL    removable:1;    /* removable */
        UW      rsv:30;         /* reserved (0) */
        W       blocksize;      /* block size in bytes */
        D       blockcont_d;    /* total number of blocks in 64-bit */
} DiskInfo_D;
</PRE
><P
>Difference between DiskInfo_D and DiskInfo is only the part of their names being <CODE
CLASS="varname"
>blockcont</CODE
> or <CODE
CLASS="varname"
>blockcont_d</CODE
>, and the data type.</P
><P
>μT-Kernel/SM does not convert a data between DiskInfo and DiskInfo_D. <TT
CLASS="literal"
>TDN_DISKINFO</TT
> and <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
> just pass the request to device driver without any modification.</P
><P
>The disk device driver must support one of <TT
CLASS="literal"
>TDN_DISKINFO</TT
> and <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
>, or both. It is recommended that <TT
CLASS="literal"
>TDN_DISKINFO</TT
> is supported wherever possible.</P
><P
>Even if the total number of blocks of entire disk exceeds W, the number of blocks of individual partition may fit within W. In that case, the preferable implementation is such that a partitions fitting within W correspond to <TT
CLASS="literal"
>TDN_DISKINFO</TT
> and partitions not fitting within W are determined to be an error (<SPAN
CLASS="errorname"
>E_PAR</SPAN
>) by <TT
CLASS="literal"
>TDN_DISKINFO</TT
>. It is also preferable that <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
> is supported even if the number of blocks fit within W.</P
><P
>There is no direct dependency between the support for <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
> and the device driver attribute <TT
CLASS="literal"
>TDA_DEV_D</TT
>. A device driver does not always have <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute even if <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
> is supported. Also, <TT
CLASS="literal"
>TDN_DISKINFO_D</TT
> is not always supported even if the device driver has <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute.</P
></DD
></DL
></DIV
></P
><P
>As the definition of common attributes described above is a part of the specification of device driver rather than μT-Kernel, it does not directly affect the μT-Kernel behavior. Each device driver does not need to implement all the functions defined in the common attributes. However, as the definition of common attributes is applicable to all the device drivers, the specification of each device driver must be specified in a way that does not conflict with these definitions.</P
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="io_operation_of_device"
>Device Input/Output Operations</A
></H2
><P
>The application interface is used to make use of the registered device drivers from an application or middleware. API of μT-Kernel provides the following functions. These functions cannot be called from a task-independent portion or while dispatch or interrupts are disabled (<SPAN
CLASS="errorname"
>E_CTX</SPAN
>).</P
><PRE
CLASS="programlisting"
>&#13;ID  tk_opn_dev( CONST UB *devnm, UINT omode )
ER  tk_cls_dev( ID dd, UINT option )
ID  tk_rea_dev( ID dd, W start, void *buf, SZ size, TMO tmout )
ID  tk_rea_dev_du( ID dd, D start_d, void *buf, SZ size, TMO_U tmout_u )
ER  tk_srea_dev( ID dd, W start, void *buf, SZ size, SZ *asize )
ER  tk_srea_dev_d( ID dd, D start_d, void *buf, SZ size, SZ *asize )
ID  tk_wri_dev( ID dd, W start, CONST void *buf, SZ size, TMO tmout )
ID  tk_wri_dev_du( ID dd, D start_d, CONST void *buf, SZ size, TMO_U tmout_u )
ER  tk_swri_dev( ID dd, W start, CONST void *buf, SZ size, SZ *asize )
ER  tk_swri_dev_d( ID dd, D start_d, CONST void *buf, SZ size, SZ *asize )
ID  tk_wai_dev( ID dd, ID reqid, SZ *asize, ER *ioer, TMO tmout )
ID  tk_wai_dev_u( ID dd, ID reqid, SZ *asize, ER *ioer, TMO_U tmout_u )
INT tk_sus_dev( UINT mode )
ID  tk_get_dev( ID devid, UB *devnm )
ID  tk_ref_dev( CONST UB *devnm, T_RDEV *rdev )
ID  tk_oref_dev( ID dd, T_RDEV *rdev )
INT tk_lst_dev( T_LDEV *ldev, INT start, INT ndev )
INT tk_evt_dev( ID devid, INT evttyp, void *evtinf )
</PRE
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_opn_dev"
>tk_opn_dev - Open Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19214"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN19216"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID dd = tk_opn_dev</CODE
>(CONST UB *devnm, UINT omode);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19225"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19227"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="21%"><COL
WIDTH="14%"><COL
WIDTH="29%"><COL
WIDTH="36%"><TBODY
VALIGN="top"
><TR
><TD
>CONST UB*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm</CODE
>
              </TD
><TD
>Device Name</TD
><TD
>Device name</TD
></TR
><TR
><TD
>UINT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>omode</CODE
>
              </TD
><TD
>Open Mode</TD
><TD
>Open mode</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19246"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19248"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="21%"
TITLE="c1"><COL
WIDTH="14%"
TITLE="c2"><COL
WIDTH="29%"
TITLE="c3"><COL
WIDTH="36%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19265"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19267"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_BUSY</SPAN
>
              </TD
><TD
>Device BUSY (exclusive open)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>Device does not exist</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Open count exceeds the limit</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19287"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19289"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19304"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19307"
>Description</A
></H4
><P
>Opens the device specified in <CODE
CLASS="varname"
>devnm</CODE
> in the mode specified in <CODE
CLASS="varname"
>omode</CODE
>, and prepares for device access. The device descriptor is passed in the return code.</P
><PRE
CLASS="synopsis"
>&#13;omode := (TD_READ || TD_WRITE || TD_UPDATE) | [TD_EXCL || TD_WEXCL || TD_REXCL]
</PRE
><PRE
CLASS="programlisting"
>&#13;#define TD_READ         0x0001          /* read only */
#define TD_WRITE        0x0002          /* write only */
#define TD_UPDATE       0x0003          /* read/write */
#define TD_EXCL         0x0100          /* exclusive */
#define TD_WEXCL        0x0200          /* exclusive write */
#define TD_REXCL        0x0400          /* exclusive read */
</PRE
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
>TD_READ</TT
></DT
><DD
><P
>read only</P
></DD
><DT
><TT
CLASS="literal"
>TD_WRITE</TT
></DT
><DD
><P
>Write only</P
></DD
><DT
><TT
CLASS="literal"
>TD_UPDATE</TT
></DT
><DD
><P
>Read/write</P
><P
>Sets the access mode.</P
><P
>When <TT
CLASS="literal"
>TD_READ</TT
> is set, <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
> cannot be used.</P
><P
>When <TT
CLASS="literal"
>TD_WRITE</TT
> is set, <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> cannot be used.</P
></DD
><DT
><TT
CLASS="literal"
>TD_EXCL</TT
></DT
><DD
><P
>Exclusive</P
></DD
><DT
><TT
CLASS="literal"
>TD_WEXCL</TT
></DT
><DD
><P
>Exclusive write</P
></DD
><DT
><TT
CLASS="literal"
>TD_REXCL</TT
></DT
><DD
><P
>Exclusive read</P
><P
>Sets the exclusive mode.</P
><P
>When <TT
CLASS="literal"
>TD_EXCL</TT
> is set, all concurrent opening is prohibited.</P
><P
>When <TT
CLASS="literal"
>TD_WEXCL</TT
> is set, concurrent opening in write mode (<TT
CLASS="literal"
>TD_WRITE</TT
> or <TT
CLASS="literal"
>TD_UPDATE</TT
>) is prohibited.</P
><P
>When <TT
CLASS="literal"
>TD_REXCL</TT
> is set, concurrent opening in read mode (<TT
CLASS="literal"
>TD_READ</TT
> or <TT
CLASS="literal"
>TD_UPDATE</TT
>) is prohibited.</P
><DIV
CLASS="table"
><A
NAME="table_tk_opn_dev"
></A
><P
><B
>Table 1. Whether Concurrent Open of Same Device is Allowed or NOT</B
></P
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="19%"
TITLE="c1"><COL
WIDTH="6%"
TITLE="c2"><COL
WIDTH="6%"
TITLE="c3"><COL
WIDTH="6%"
TITLE="c4"><COL
WIDTH="6%"
TITLE="c5"><COL
WIDTH="6%"
TITLE="c6"><COL
WIDTH="6%"
TITLE="c7"><COL
WIDTH="6%"
TITLE="c8"><COL
WIDTH="6%"
TITLE="c9"><COL
WIDTH="6%"
TITLE="c10"><COL
WIDTH="6%"
TITLE="c11"><COL
WIDTH="6%"
TITLE="c12"><COL
WIDTH="6%"
TITLE="c13"><COL
WIDTH="6%"
TITLE="c14"><TBODY
VALIGN="top"
><TR
><TD
COLSPAN="2"
ROWSPAN="3"
VALIGN="middle"
>Present Open Mode</TD
><TD
COLSPAN="12"
ALIGN="center"
>Concurrent Open Mode</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="center"
>No exclusive mode</TD
><TD
COLSPAN="3"
ALIGN="center"
>TD_WEXCL</TD
><TD
COLSPAN="3"
ALIGN="center"
>TD_REXCL</TD
><TD
COLSPAN="3"
ALIGN="center"
>TD_EXCL</TD
></TR
><TR
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>W</TD
></TR
><TR
><TD
ROWSPAN="3"
VALIGN="middle"
>No exclusive mode</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ROWSPAN="3"
VALIGN="middle"
>TD_WEXCL</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ROWSPAN="3"
VALIGN="middle"
>TD_REXCL</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ROWSPAN="3"
VALIGN="middle"
>TD_EXCL</TD
><TD
ALIGN="center"
>R</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>U</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
><TR
><TD
ALIGN="center"
>W</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
></DIV
><PRE
CLASS="synopsis"
>&#13;R = TD_READ
W = TD_WRITE
U = TD_UPDATE
YES = Yes, can be opened
NO = No, cannot be opened (E_BUSY)
</PRE
></DD
></DL
></DIV
><P
>When a physical device is opened, the logical devices belonging to it are all treated as having been opened in the same mode, and are processed as exclusive open.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_cls_dev"
>tk_cls_dev - Close Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19578"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN19580"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_cls_dev</CODE
>(ID dd, UINT option);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19589"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19591"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>UINT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>option</CODE
>
              </TD
><TD
>Close Option</TD
><TD
>Close option</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19610"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19612"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19625"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19627"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19640"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19642"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19657"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19660"
>Description</A
></H4
><P
>Closes device descriptor <CODE
CLASS="varname"
>dd</CODE
>. If a request is being processed, the processing is aborted and the device is closed.</P
><PRE
CLASS="synopsis"
>&#13;option := [TD_EJECT]
</PRE
><PRE
CLASS="programlisting"
>&#13;#define TD_EJECT        0x0001          /* Eject media */
</PRE
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
>TD_EJECT</TT
></DT
><DD
><P
>Eject media</P
><P
>If the same device has not been opened by another task, the media is ejected. In the case of devices that cannot eject their media, the request is ignored.</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_rea_dev"
>tk_rea_dev - Start Read Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19675"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN19677"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID reqid = tk_rea_dev</CODE
>(ID dd, W start, void *buf, SZ size, TMO tmout);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19692"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19694"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>W</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Read start location (≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer location for putting the read data</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Read Size</TD
><TD
>Read size</TD
></TR
><TR
><TD
>TMO</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (ms)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19731"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19733"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19750"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19752"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (read not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Busy processing other requests</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19782"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19784"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19799"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19802"
>Description</A
></H4
><P
>Initiates reading device-specific data or attribute data from the specified device. This function initiates reading only, returning to its caller without waiting for the read operation to finish. The space specified in <CODE
CLASS="varname"
>buf</CODE
> must be retained until the read operation completes. Read completion is waited for by <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>. The time required for initiating read operation differs among device drivers; return of control is not necessarily immediate.</P
><P
>In the case of device-specific data, the <CODE
CLASS="varname"
>start</CODE
> and <CODE
CLASS="varname"
>size</CODE
> units are defined for each device. With attribute data, <CODE
CLASS="varname"
>start</CODE
> is an attribute data number and <CODE
CLASS="varname"
>size</CODE
> is in bytes. The attribute data of the data number specified in <CODE
CLASS="varname"
>start</CODE
> is read. Normally <CODE
CLASS="varname"
>size</CODE
> must be at least as large as the size of the attribute data to be read. Reading of multiple attribute data in one operation is not possible. When <CODE
CLASS="varname"
>size</CODE
> = 0 is specified, actual reading does not take place but the current size of data that can be read is checked.</P
><P
>Whether or not a new request can be accepted while a read or write operation is in progress depends on the device driver. If a new request cannot be accepted, the request is queued. The timeout for request waiting is set in <CODE
CLASS="varname"
>tmout</CODE
>. The <TT
CLASS="literal"
>TMO_POL</TT
> or <TT
CLASS="literal"
>TMO_FEVR</TT
> attribute can be specified in <CODE
CLASS="varname"
>tmout</CODE
>. Note that the timeout applies to the request acceptance. Once a request has been accepted, this function does not time out.</P
><P
>It is permissible to call this API to a driver that has <TT
CLASS="literal"
>TDA_DEV_D</TT
> or <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute. In that case, the parameters are converted appropriately by μT-Kernel/SM. For example, if the device driver has <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute, the timeout interval (milliseconds) specified in <CODE
CLASS="varname"
>tmout</CODE
> of this API is converted to time in microseconds, and then passed to the driver with <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_rea_dev_du"
>tk_rea_dev_du - Read Device (64-bit, Microseconds)</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19828"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN19830"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID reqid = tk_rea_dev_du</CODE
>(ID dd, D start_d, void *buf, SZ size, TMO_U tmout_u);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19845"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19847"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>D</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start_d</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Read start location (64 bit, ≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer location for putting the read data</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Read Size</TD
><TD
>Read size</TD
></TR
><TR
><TD
>TMO_U</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout_u</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (in microseconds)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19884"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19886"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19903"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19905"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (read not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Busy processing other requests</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19935"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19937"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19952"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN19955"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_LARGEDEV</TT
>
              </TD
><TD
>Support of large mass-storage devices (64-bit)</TD
></TR
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_USEC</TT
>
              </TD
><TD
>Support of microsecond</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19968"
>Description</A
></H4
><P
>This API takes the parameters <CODE
CLASS="varname"
>start_d</CODE
> (64 bits) and <CODE
CLASS="varname"
>tmout_u</CODE
> (64-bit microseconds), instead of the parameters <CODE
CLASS="varname"
>start</CODE
> and <CODE
CLASS="varname"
>tmout</CODE
> of <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>.</P
><P
>Its specification is the same as that of <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>, except that the parameters are changed to <CODE
CLASS="varname"
>start_d</CODE
> and <CODE
CLASS="varname"
>tmout_u</CODE
>. For more details, see the description of <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19981"
>Additional Notes</A
></H4
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute, the error code <SPAN
CLASS="errorname"
>E_PAR</SPAN
> is returned when specifying a value that is out of the range of W for the start position <CODE
CLASS="varname"
>start_d</CODE
>.</P
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute (does not supports microseconds), it cannot handle the timeout in microseconds. In that case, the timeout (in microseconds) specified by this API in <CODE
CLASS="varname"
>tmout_u</CODE
> is rounded to the time in milliseconds and passed to the device driver.</P
><P
>Thus, the appropriate conversion of parameters is executed by μT-Kernel/SM. The application does not have to know whether the device driver has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute or not, i.e. whether the device driver supports 64 bits or not.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_srea_dev"
>tk_srea_dev - Synchronous Read</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN19994"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN19996"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_srea_dev</CODE
>(ID dd, W start, void *buf, SZ size, SZ *asize);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20011"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20013"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>W</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Read start location (≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer location for putting the read data</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Read Size</TD
><TD
>Read size</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Pointer to the area to return the read size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20050"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20052"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Actually read size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20071"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20073"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (read not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20099"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20101"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20116"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20119"
>Description</A
></H4
><P
>Synchronous read. This is equivalent to the following.</P
><PRE
CLASS="programlisting"
>&#13;ER tk_srea_dev( ID dd, W start, void *buf, SZ size, SZ *asize )
{
        ER      er, ioer;

        er = tk_rea_dev(dd, start, buf, size, TMO_FEVR);
        if ( er &#62; 0 ) {
                er = tk_wai_dev(dd, er, asize, &#38;ioer, TMO_FEVR);
                if ( er &#62; 0 ) er = ioer;
        }

        return er;
}
</PRE
><P
>This API can be used for a device driver that has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute. In that case, the parameters are converted appropriately by μT-Kernel/SM.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_srea_dev_d"
>tk_srea_dev_d - Synchronous Read (64-bit)</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20127"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20129"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_srea_dev_d</CODE
>(ID dd, D start_d, void *buf, SZ size, SZ *asize);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20144"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20146"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>D</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start_d</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Read start location (64 bit, ≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer location for putting the read data</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Read Size</TD
><TD
>Read size</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Pointer to the area to return the read size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20183"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20185"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Actually read size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20204"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20206"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (read not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20232"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20234"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20249"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20252"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_LARGEDEV</TT
>
              </TD
><TD
>Support of large mass-storage devices (64-bit)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20261"
>Description</A
></H4
><P
>This API takes the 64-bit parameter <CODE
CLASS="varname"
>start_d</CODE
>, instead of the parameter <CODE
CLASS="varname"
>start</CODE
> of <A
HREF="device_management_functions.html#tk_srea_dev"
>tk_srea_dev</A
>.</P
><P
>Its specification is the same as that of <A
HREF="device_management_functions.html#tk_srea_dev"
>tk_srea_dev</A
>, except that the parameter is changed to <CODE
CLASS="varname"
>start_d</CODE
>. For more details, see the description of <A
HREF="device_management_functions.html#tk_srea_dev"
>tk_srea_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20271"
>Additional Notes</A
></H4
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute, the error code <SPAN
CLASS="errorname"
>E_PAR</SPAN
> is returned when specifying a value that is out of the range of W for the start position <CODE
CLASS="varname"
>start_d</CODE
>.</P
><P
>Thus, the appropriate conversion of parameters is executed by μT-Kernel/SM. The application does not have to know whether the device driver has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute or not, i.e. whether the device driver supports 64 bits or not.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_wri_dev"
>tk_wri_dev - Start Write Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20281"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20283"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID reqid = tk_wri_dev</CODE
>(ID dd, W start, CONST void *buf, SZ size, TMO tmout);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20298"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20300"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>W</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>write start location (≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>CONST void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer holding data to be written</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Write Size</TD
><TD
>Size of data to be written</TD
></TR
><TR
><TD
>TMO</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (ms)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20337"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20339"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20356"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20358"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (write not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_RONLY</SPAN
>
              </TD
><TD
>Read-only device</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Busy processing other requests</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20391"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20393"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20408"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20411"
>Description</A
></H4
><P
>Initiates writing device-specific data or attribute data to a device. This function initiates writing only, returning to its caller without waiting for the write operation to finish. The space specified in <CODE
CLASS="varname"
>buf</CODE
> must be retained until the write operation completes. Write completion is waited for by <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>. The time required for initiating write operation differs among device drivers; return of control is not necessarily immediate.</P
><P
>In the case of device-specific data, the <CODE
CLASS="varname"
>start</CODE
> and <CODE
CLASS="varname"
>size</CODE
> units are defined for each device. With attribute data, <CODE
CLASS="varname"
>start</CODE
> is an attribute data number and <CODE
CLASS="varname"
>size</CODE
> is in bytes. The attribute data of the data number specified in <CODE
CLASS="varname"
>start</CODE
> is written. Normally <CODE
CLASS="varname"
>size</CODE
> must be at least as large as the size of the attribute data to be written. Multiple attribute data cannot be written in one operation. When <CODE
CLASS="varname"
>size</CODE
> = 0 is specified, actual writing does not take place but the current size of data that can be written is checked.</P
><P
>Whether or not a new request can be accepted while a read or write operation is in progress depends on the device driver. If a new request cannot be accepted, the request is queued. The timeout for request waiting is set in <CODE
CLASS="varname"
>tmout</CODE
>. The <TT
CLASS="literal"
>TMO_POL</TT
> or <TT
CLASS="literal"
>TMO_FEVR</TT
> attribute can be specified in <CODE
CLASS="varname"
>tmout</CODE
>. Note that the timeout applies to the request acceptance. Once a request has been accepted, this function does not time out.</P
><P
>It is permissible to call this API to a driver that has <TT
CLASS="literal"
>TDA_DEV_D</TT
> or <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute. In that case, the parameters are converted appropriately by μT-Kernel/SM. For example, if the device driver has <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute, the timeout interval ( milliseconds) specified in <CODE
CLASS="varname"
>tmout</CODE
> of this API is converted to time in microseconds, and then passed to the driver with <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_wri_dev_du"
>tk_wri_dev_du - Write Device (64-bit, Microseconds)</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20437"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20439"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID reqid = tk_wri_dev_du</CODE
>(ID dd, D start_d, CONST void *buf, SZ size, TMO_U tmout_u);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20454"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20456"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>D</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start_d</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Write start location (64 bit, ≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>CONST void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer holding data to be written</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Write Size</TD
><TD
>Size of data to be written</TD
></TR
><TR
><TD
>TMO_U</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout_u</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (in microseconds)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20493"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20495"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20512"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20514"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (write not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_RONLY</SPAN
>
              </TD
><TD
>Read-only device</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Busy processing other requests</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20547"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20549"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20564"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20567"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_LARGEDEV</TT
>
              </TD
><TD
>Support of large mass-storage devices (64-bit)</TD
></TR
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_USEC</TT
>
              </TD
><TD
>Support of microsecond</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20580"
>Description</A
></H4
><P
>This API takes the parameters <CODE
CLASS="varname"
>start_d</CODE
> (64 bits) and <CODE
CLASS="varname"
>tmout_u</CODE
> (64-bit microseconds), instead of the parameters <CODE
CLASS="varname"
>start</CODE
> and <CODE
CLASS="varname"
>tmout</CODE
> of <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>.</P
><P
>Its specification is the same as that of <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>, except that the parameters are changed to <CODE
CLASS="varname"
>start_d</CODE
> and <CODE
CLASS="varname"
>tmout_u</CODE
>. For more details, see the description of <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20593"
>Additional Notes</A
></H4
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute, the error code <SPAN
CLASS="errorname"
>E_PAR</SPAN
> is returned when specifying a value that is out of the range of W for the start position <CODE
CLASS="varname"
>start_d</CODE
>.</P
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute (does not supports microseconds), it cannot handle the timeout in microseconds. In that case, the timeout (in microseconds) specified by this API in <CODE
CLASS="varname"
>tmout_u</CODE
> is rounded to the time in milliseconds and passed to the device driver.</P
><P
>Thus, the appropriate conversion of parameters is executed by μT-Kernel/SM. The application does not have to know whether the device driver has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute or not, i.e. whether the device driver supports 64 bits or not.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_swri_dev"
>tk_swri_dev - Synchronous Write</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20606"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20608"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_swri_dev</CODE
>(ID dd, W start, CONST void *buf, SZ size, SZ *asize);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20623"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20625"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>W</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Write start location (≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>CONST void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer holding data to be written</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Write Size</TD
><TD
>Size of data to be written</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Pointer to the area to return the written size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20662"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20664"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Actually written size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20683"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20685"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (write not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_RONLY</SPAN
>
              </TD
><TD
>Read-only device</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20714"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20716"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20731"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20734"
>Description</A
></H4
><P
>Synchronous write. This is equivalent to the following.</P
><PRE
CLASS="programlisting"
>&#13;ER tk_swri_dev( ID dd, W start, void *buf, SZ size, SZ *asize )
{
        ER      er, ioer;

        er = tk_wri_dev(dd, start, buf, size, TMO_FEVR);
        if ( er &#62; 0 ) {
                er = tk_wai_dev(dd, er, asize, &#38;ioer, TMO_FEVR);
                if ( er &#62; 0 ) er = ioer;
        }

        return er;
}
</PRE
><P
>This API can be used for a device driver that has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute. In that case, the parameters are converted appropriately by μT-Kernel/SM.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_swri_dev_d"
>tk_swri_dev_d - Synchronous Write (64-bit)</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20742"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20744"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_swri_dev_d</CODE
>(ID dd, D start_d, CONST void *buf, SZ size, SZ *asize);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20759"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20761"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>D</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start_d</CODE
>
              </TD
><TD
>Start Location</TD
><TD
>Write start location (64 bit, ≧ 0: Device-specific data, &#60; 0: Attribute data)</TD
></TR
><TR
><TD
>CONST void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>buf</CODE
>
              </TD
><TD
>Buffer</TD
><TD
>Buffer holding data to be written</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>size</CODE
>
              </TD
><TD
>Write Size</TD
><TD
>Size of data to be written</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Pointer to the area to return the written size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20798"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20800"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actual Size</TD
><TD
>Actually written size</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20819"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20821"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OACV</SPAN
>
              </TD
><TD
>Open mode is invalid (write not permitted)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_RONLY</SPAN
>
              </TD
><TD
>Read-only device</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of requests exceeds the limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20850"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20852"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20867"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20870"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_LARGEDEV</TT
>
              </TD
><TD
>Support of large mass-storage devices (64-bit)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20879"
>Description</A
></H4
><P
>This API takes the 64-bit parameter <CODE
CLASS="varname"
>start_d</CODE
>, instead of the parameter <CODE
CLASS="varname"
>start</CODE
> of <A
HREF="device_management_functions.html#tk_swri_dev"
>tk_swri_dev</A
>.</P
><P
>Its specification is the same as that of <A
HREF="device_management_functions.html#tk_swri_dev"
>tk_swri_dev</A
>, except that the parameter is changed to <CODE
CLASS="varname"
>start_d</CODE
>. For more details, see the description of <A
HREF="device_management_functions.html#tk_swri_dev"
>tk_swri_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20889"
>Additional Notes</A
></H4
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute, the error code <SPAN
CLASS="errorname"
>E_PAR</SPAN
> is returned when specifying a value that is out of the range of W for the start position <CODE
CLASS="varname"
>start_d</CODE
>.</P
><P
>Thus, the appropriate conversion of parameters is executed by μT-Kernel/SM. The application does not have to know whether the device driver has the <TT
CLASS="literal"
>TDA_DEV_D</TT
> attribute or not, i.e. whether the device driver supports 64 bits or not.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_wai_dev"
>tk_wai_dev - Wait for Request Completion for Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20899"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN20901"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID creqid = tk_wai_dev</CODE
>(ID dd, ID reqid, SZ *asize, ER *ioer, TMO tmout);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20916"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20918"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actually Read/Written Size</TD
><TD
>Pointer to the area to return the read/written size</TD
></TR
><TR
><TD
>ER*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ioer</CODE
>
              </TD
><TD
>I/O Error</TD
><TD
>Pointer to the area to return I/O error</TD
></TR
><TR
><TD
>TMO</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Timeout (ms)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20955"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20957"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>creqid</CODE
>
              </TD
><TD
>Completed Request ID</TD
><TD
>Completed request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actually Read/Written Size</TD
><TD
>Actually read/written size</TD
></TR
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ioer</CODE
>
              </TD
><TD
>I/O Error</TD
><TD
>I/O error</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN20986"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN20988"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not opened, or <CODE
CLASS="varname"
>reqid</CODE
> is invalid or not a request for <CODE
CLASS="varname"
>dd</CODE
></TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OBJ</SPAN
>
              </TD
><TD
>Another task is already waiting for request <CODE
CLASS="varname"
>reqid</CODE
></TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>No requests are being processed (only when <CODE
CLASS="varname"
>reqid</CODE
> = 0)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Timeout (processing continues)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21021"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21023"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21038"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21041"
>Description</A
></H4
><P
>Waits for completion of request <CODE
CLASS="varname"
>reqid</CODE
> for device <CODE
CLASS="varname"
>dd</CODE
>. If <CODE
CLASS="varname"
>reqid</CODE
> = 0 is set, this function waits for completion of any pending request to <CODE
CLASS="varname"
>dd</CODE
>. This function waits for completion only of requests currently processing when the function is called. A request issued after <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> was called is not waited for.</P
><P
>When multiple requests are being processed concurrently, the order of their completion is not necessarily the same as the order of request but is dependent on the device driver. Processing is, however, guaranteed to be performed in a sequence such that the result is consistent with the order of requesting. When processing a read operation from a disk, for example, the sequence might be changed as follows.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Block number request sequence</DT
><DD
><P
>1 4 3 2 5</P
></DD
><DT
>Block number processing sequence</DT
><DD
><P
>1 2 3 4 5</P
></DD
></DL
></DIV
><P
>Disk access can be made more efficient by changing the sequence as above with the aim of reducing seek time and spin wait time.</P
><P
>The timeout for waiting for completion is set in <CODE
CLASS="varname"
>tmout</CODE
>. The <TT
CLASS="literal"
>TMO_POL</TT
> or <TT
CLASS="literal"
>TMO_FEVR</TT
> attribute can be specified for <CODE
CLASS="varname"
>tmout</CODE
>. If a timeout error is returned (<SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>), <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> must be called again to wait for completion since the request processing is still ongoing. When <CODE
CLASS="varname"
>reqid</CODE
> &#62; 0 and <CODE
CLASS="varname"
>tmout</CODE
> = <TT
CLASS="literal"
>TMO_FEVR</TT
> are both set, the processing must be completed without timing out.</P
><P
>If the device driver returns a processing result error (such as I/O error) for the requested processing, the error code is stored in <CODE
CLASS="varname"
>ioer</CODE
> instead of the return code. Specifically, the error code, which is stored in <CODE
CLASS="varname"
>error</CODE
> of the request packet T_DEVREQ by the wait-for-completion function (<A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>) called for processing <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>, is returned to <CODE
CLASS="varname"
>ioer</CODE
> as the processing result error.</P
><P
>On the other hand, the return code is used for errors when the wait request itself was not handled properly. When error is passed in the return code, <CODE
CLASS="varname"
>ioer</CODE
> has no meaning. Note also that if an error is passed in the return code, <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> must be called again to wait for completion since the processing is still ongoing. For more details, see <A
HREF="device_management_functions.html#waitfn"
>the Section called <I
>waitfn - Wait-for-completion function</I
></A
>.</P
><P
>If a task exception is raised during completion waiting by <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>, the request in <CODE
CLASS="varname"
>reqid</CODE
> is aborted and processing is completed. The result of aborting the requested processing is dependent on the device driver. When <CODE
CLASS="varname"
>reqid</CODE
> = 0 was set, however, requests are not aborted but are treated as timeout. In this case <SPAN
CLASS="errorname"
>E_ABORT</SPAN
> rather than <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
> is returned.</P
><P
>It is not possible for multiple tasks to wait for completion of the same request ID at the same time. If there is a task waiting for request completion with <CODE
CLASS="varname"
>reqid</CODE
> = 0 set, another task cannot wait for completion for the same <CODE
CLASS="varname"
>dd</CODE
>. Similarly, if there is a task waiting for request completion with <CODE
CLASS="varname"
>reqid</CODE
> &#62; 0 set, another task cannot wait for completion specifying <CODE
CLASS="varname"
>reqid</CODE
> = 0.</P
><P
>It is permissible to call this API to a driver with <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute In such instances, μT-Kernel/SM converts the parameter(s) appropriately. For example, if the device driver has <TT
CLASS="literal"
>TDA_TMO_U</TT
>attribute, the timeout in milliseconds specified in <CODE
CLASS="varname"
>tmout</CODE
> of this API is converted to timeout value in microseconds, and is passed to the driver with <TT
CLASS="literal"
>TDA_TMO_U</TT
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_wai_dev_u"
>tk_wai_dev_u - Wait Device (Microseconds)</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21098"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21100"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID creqid = tk_wai_dev_u</CODE
>(ID dd, ID reqid, SZ *asize, ER *ioer, TMO_U tmout_u);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21115"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21117"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>reqid</CODE
>
              </TD
><TD
>Request ID</TD
><TD
>Request ID</TD
></TR
><TR
><TD
>SZ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actually Read/Written Size</TD
><TD
>Pointer to the area to return the read/written size</TD
></TR
><TR
><TD
>ER*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ioer</CODE
>
              </TD
><TD
>I/O Error</TD
><TD
>Pointer to the area to return I/O error</TD
></TR
><TR
><TD
>TMO_U</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout_u</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Timeout (in microseconds)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21154"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21156"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>creqid</CODE
>
              </TD
><TD
>Completed Request ID</TD
><TD
>Completed request ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>asize</CODE
>
              </TD
><TD
>Actually Read/Written Size</TD
><TD
>Actually read/written size</TD
></TR
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ioer</CODE
>
              </TD
><TD
>I/O Error</TD
><TD
>I/O error</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21185"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21187"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not opened, or <CODE
CLASS="varname"
>reqid</CODE
> is invalid or not a request for <CODE
CLASS="varname"
>dd</CODE
></TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_OBJ</SPAN
>
              </TD
><TD
>Another task is already waiting for request <CODE
CLASS="varname"
>reqid</CODE
></TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>No requests are being processed (only when <CODE
CLASS="varname"
>reqid</CODE
> = 0)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>
              </TD
><TD
>Timeout (processing continues)</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ABORT</SPAN
>
              </TD
><TD
>Processing aborted</TD
></TR
><TR
><TD
>Other</TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21220"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21222"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21237"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21240"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_USEC</TT
>
              </TD
><TD
>Support of microsecond</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21249"
>Description</A
></H4
><P
>This API takes the parameter <CODE
CLASS="varname"
>tmout_u</CODE
> (64-bit microseconds), instead of the parameter <CODE
CLASS="varname"
>tmout</CODE
> of <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>.</P
><P
>Its specification is the same as that of <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>, except that the parameter changed to <CODE
CLASS="varname"
>tmout_u</CODE
>. For more details, see the description of <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21259"
>Additional Notes</A
></H4
><P
>If the corresponding device driver does not have the <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute (does not supports microseconds), it cannot handle the timeout in microseconds. In that case, the timeout (in microseconds) specified by this API in <CODE
CLASS="varname"
>tmout_u</CODE
> is rounded to the time in milliseconds and passed to the device driver.</P
><P
>Thus, the appropriate conversion of parameters is executed by μT-Kernel/SM. The application does not have to know whether the device driver has the <TT
CLASS="literal"
>TDA_TMO_U</TT
> attribute or not, i.e., whether the device driver supports microseconds or not.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_sus_dev"
>tk_sus_dev - Suspends Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21268"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21270"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT dissus = tk_sus_dev</CODE
>(UINT mode);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21277"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21279"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>UINT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>mode</CODE
>
              </TD
><TD
>Mode</TD
><TD
>Mode</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21292"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21294"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dissus</CODE
>
              </TD
><TD
>Suspend Disable Request Count</TD
><TD
>Suspend disable request count</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21311"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21313"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_BUSY</SPAN
>
              </TD
><TD
>Suspend already disabled</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_QOVR</SPAN
>
              </TD
><TD
>Suspend disable request count limit exceeded</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21326"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21328"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21343"
>Related Service Profile Items</A
></H4
><P
>Only when all the service profile items below are set to be effective, this API can be used.</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21346"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="38%"
TITLE="c1"><COL
WIDTH="62%"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <TT
CLASS="literal"
>TK_SUPPORT_LOWPOWER</TT
>
              </TD
><TD
>Support of power management functions</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21355"
>Description</A
></H4
><P
>Performs the processing specified in <CODE
CLASS="varname"
>mode</CODE
>, then passes the resulting suspend disable request count in the return code.</P
><PRE
CLASS="synopsis"
>&#13;mode := ( (TD_SUSPEND | [TD_FORCE]) || TD_DISSUS || TD_ENASUS || TD_CHECK)
</PRE
><PRE
CLASS="programlisting"
>&#13;#define TD_SUSPEND      0x0001      /* suspend */
#define TD_DISSUS       0x0002      /* disable suspension */
#define TD_ENASUS       0x0003      /* enable suspension */
#define TD_CHECK        0x0004      /* get suspend disable request count */
#define TD_FORCE        0x8000      /* forced suspend specification */
</PRE
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="literal"
>TD_SUSPEND</TT
></DT
><DD
><P
>Suspend</P
><P
>If suspending is enabled, suspends processing.</P
><P
>If suspending is disabled, returns <SPAN
CLASS="errorname"
>E_BUSY</SPAN
>.</P
></DD
><DT
><TT
CLASS="literal"
>TD_SUSPEND|TD_FORCE</TT
></DT
><DD
><P
>Forcibly suspend</P
><P
>Suspends even in suspend disabled state.</P
></DD
><DT
><TT
CLASS="literal"
>TD_DISSUS</TT
></DT
><DD
><P
>Disable suspension</P
><P
>Disables suspension.</P
></DD
><DT
><TT
CLASS="literal"
>TD_ENASUS</TT
></DT
><DD
><P
>Enable suspension</P
><P
>Enables suspension.</P
></DD
><DT
><TT
CLASS="literal"
>TD_CHECK</TT
></DT
><DD
><P
>Get suspend disable count</P
><P
>Gets only the number of times suspend disable has been requested.</P
></DD
></DL
></DIV
><P
>Suspension is performed in the following steps.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Processing prior to start of suspension in each subsystem</P
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_SUSPEND_BEGIN</TT
>, 0)</P
></LI
><LI
><P
>Suspension processing in devices</P
></LI
><LI
><P
>Processing after completion of suspension in each subsystem</P
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_SUSPEND_DONE</TT
>, 0)</P
></LI
><LI
><P
>Suspended state</P
><P
><A
HREF="system_management_functions.html#tk_set_pow"
>tk_set_pow</A
>(<TT
CLASS="literal"
>TPW_DOSUSPEND</TT
>)</P
></LI
></OL
><P
>Resumption from SUSPEND state is performed in the following steps.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Return from SUSPEND state</P
><P
>Return from <A
HREF="system_management_functions.html#tk_set_pow"
>tk_set_pow</A
>(<TT
CLASS="literal"
>TPW_DOSUSPEND</TT
>)</P
></LI
><LI
><P
>Processing prior to start of resumption in each subsystem</P
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_RESUME_BEGIN</TT
>, 0)</P
></LI
><LI
><P
>Resumption processing in devices</P
></LI
><LI
><P
>Processing after completion of resumption in each subsystem</P
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_RESUME_DONE</TT
>, 0)</P
></LI
></OL
><P
>The number of suspend disable requests is counted. Suspension is enabled only if the same number of suspend enable requests is made. At system boot, the suspend disable count is 0 and suspension is enabled. The maximum suspend disable request count is implementation-dependent, but must be at least 255. When the upper limit is exceeded, <SPAN
CLASS="errorname"
>E_QOVR</SPAN
> is returned.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_get_dev"
>tk_get_dev - Get Device Name</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21436"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21438"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID pdevid = tk_get_dev</CODE
>(ID devid, UB *devnm);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21447"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21449"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID</TD
></TR
><TR
><TD
>UB*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm</CODE
>
              </TD
><TD
>Device Name</TD
><TD
>Pointer to the device name storage location</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21468"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21470"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>pdevid</CODE
>
              </TD
><TD
>Device ID of Physical Device</TD
><TD
>Device ID of the physical device</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
><TR
><TD
>UB</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm</CODE
>
              </TD
><TD
>Device Name</TD
><TD
>Device name</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21493"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21495"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>The device specified in <CODE
CLASS="varname"
>devid</CODE
> does not exist</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21505"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21507"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21522"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21525"
>Description</A
></H4
><P
>Gets the device name of the device specified in <CODE
CLASS="varname"
>devid</CODE
> and puts the result in <CODE
CLASS="varname"
>devnm</CODE
>.</P
><P
><CODE
CLASS="varname"
>devid</CODE
> is the device ID of either a physical device or a logical device.</P
><P
>If <CODE
CLASS="varname"
>devid</CODE
> is a physical device, the physical device name is put in <CODE
CLASS="varname"
>devnm</CODE
>.</P
><P
>If <CODE
CLASS="varname"
>devid</CODE
> is a logical device, the logical device name is put in <CODE
CLASS="varname"
>devnm</CODE
>.</P
><P
><CODE
CLASS="varname"
>devnm</CODE
> requires a space of <TT
CLASS="literal"
>L_DEVNM</TT
> + 1 bytes or larger.</P
><P
>The device ID of the physical device to which device <CODE
CLASS="varname"
>devid</CODE
> belongs is passed in the return code.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_ref_dev"
>tk_ref_dev - Get Device Information</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21545"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21547"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID devid = tk_ref_dev</CODE
>(CONST UB *devnm, T_RDEV *rdev);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21556"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21558"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>CONST UB*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm</CODE
>
              </TD
><TD
>Device Name</TD
><TD
>Device name</TD
></TR
><TR
><TD
>T_RDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>rdev</CODE
>
              </TD
><TD
>Packet to Return Device Information</TD
><TD
>Pointer to the area to return the device information</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21577"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21579"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
><CODE
CLASS="varname"
>rdev</CODE
> Detail:</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21598"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ATR</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devatr</CODE
>
              </TD
><TD
>Device Attribute</TD
><TD
>Device attributes</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>blksz</CODE
>
              </TD
><TD
>Block Size of Device-specific Data</TD
><TD
>Block size of device-specific data (-1: unknown)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>nsub</CODE
>
              </TD
><TD
>Subunit Count</TD
><TD
>Number of subunits</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>subno</CODE
>
              </TD
><TD
>Subunit Number</TD
><TD
>0: Physical device, 1 to nsub: Subunit number+1</TD
></TR
><TR
><TD
COLSPAN="4"
>(Other implementation-dependent parameters may be added beyond this point.)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21631"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21633"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>The device specified in <CODE
CLASS="varname"
>devnm</CODE
> does not exist</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21643"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21645"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21660"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21663"
>Description</A
></H4
><P
>Gets device information about the device specified in <CODE
CLASS="varname"
>devnm</CODE
>, and puts the result in <CODE
CLASS="varname"
>rdev</CODE
>. If <CODE
CLASS="varname"
>rdev</CODE
> = <TT
CLASS="literal"
>NULL</TT
> is set, the device information is not stored.</P
><P
><CODE
CLASS="varname"
>nsub</CODE
> indicates the number of physical device subunits belonging to the device specified in <CODE
CLASS="varname"
>devnm</CODE
>.</P
><P
>The device ID of the device specified in <CODE
CLASS="varname"
>devnm</CODE
> is passed in the return code.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_oref_dev"
>tk_oref_dev - Get Device Information</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21677"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21679"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID devid = tk_oref_dev</CODE
>(ID dd, T_RDEV *rdev);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21688"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21690"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>dd</CODE
>
              </TD
><TD
>Device Descriptor</TD
><TD
>Device descriptor</TD
></TR
><TR
><TD
>T_RDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>rdev</CODE
>
              </TD
><TD
>Packet to Return Device Information</TD
><TD
>Pointer to the area to return the device information</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21709"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21711"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
><CODE
CLASS="varname"
>rdev</CODE
> Detail:</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21730"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ATR</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devatr</CODE
>
              </TD
><TD
>Device Attribute</TD
><TD
>Device attributes</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>blksz</CODE
>
              </TD
><TD
>Block Size of Device-specific Data</TD
><TD
>Block size of device-specific data (-1: unknown)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>nsub</CODE
>
              </TD
><TD
>Subunit Count</TD
><TD
>Number of subunits</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>subno</CODE
>
              </TD
><TD
>Subunit Number</TD
><TD
>0: Physical device, 1 to nsub: Subunit number+1</TD
></TR
><TR
><TD
COLSPAN="4"
>(Other implementation-dependent parameters may be added beyond this point.)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21763"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21765"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_ID</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>dd</CODE
> is invalid or not open</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21775"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21777"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21792"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21795"
>Description</A
></H4
><P
>Gets device information about the device specified in <CODE
CLASS="varname"
>dd</CODE
>, and puts the result in <CODE
CLASS="varname"
>rdev</CODE
>. If <CODE
CLASS="varname"
>rdev</CODE
> = <TT
CLASS="literal"
>NULL</TT
> is set, the device information is not stored.</P
><P
><CODE
CLASS="varname"
>nsub</CODE
> indicates the number of physical device subunits belonging to the device specified in <CODE
CLASS="varname"
>dd</CODE
>.</P
><P
>The device ID of the device specified in <CODE
CLASS="varname"
>dd</CODE
> is passed in the return code.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_lst_dev"
>tk_lst_dev - Get Registered Device Information</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21809"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21811"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT remcnt = tk_lst_dev</CODE
>(T_LDEV *ldev, INT start, INT ndev);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21822"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21824"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>T_LDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ldev</CODE
>
              </TD
><TD
>List of Devices</TD
><TD
>Location of registered device information (array)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>start</CODE
>
              </TD
><TD
>Starting Number</TD
><TD
>Starting number</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ndev</CODE
>
              </TD
><TD
>Number of Devices</TD
><TD
>Number to acquire</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21849"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21851"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>remcnt</CODE
>
              </TD
><TD
>Remaining Device Count</TD
><TD
>Number of remaining registrations</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
><CODE
CLASS="varname"
>ldev</CODE
> Detail:</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21870"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ATR</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devatr</CODE
>
              </TD
><TD
>Device Attribute</TD
><TD
>Device attributes</TD
></TR
><TR
><TD
>SZ</TD
><TD
>&#13;                <CODE
CLASS="varname"
>blksz</CODE
>
              </TD
><TD
>Block Size of Device-specific Data</TD
><TD
>Block size of device-specific data (-1: unknown)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>nsub</CODE
>
              </TD
><TD
>Subunit Count</TD
><TD
>Number of subunits</TD
></TR
><TR
><TD
>UB</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm[L_DEVNM]</CODE
>
              </TD
><TD
>Physical Device Name</TD
><TD
>Physical device name</TD
></TR
><TR
><TD
COLSPAN="4"
>(Other implementation-dependent parameters may be added beyond this point.)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21903"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21905"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
><CODE
CLASS="varname"
>start</CODE
> exceeds the registered number</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21915"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21917"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21932"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21935"
>Description</A
></H4
><P
>Gets information about registered devices. Registered devices are managed per physical device. The registered device information is therefore also obtained per physical device.</P
><P
>When the number of registered devices is N, number are assigned serially to devices from 0 to N - 1. Starting from the number specified in <CODE
CLASS="varname"
>start</CODE
> in accordance with this scheme, the number of registrations specified in <CODE
CLASS="varname"
>ndev</CODE
> is acquired and put in <CODE
CLASS="varname"
>ldev</CODE
>. The space specified in <CODE
CLASS="varname"
>ldev</CODE
> must be large enough to hold <CODE
CLASS="varname"
>ndev</CODE
> registration information. The number of remaining registrations after <CODE
CLASS="varname"
>start</CODE
> (N-<CODE
CLASS="varname"
>start</CODE
>) is passed in the return code.</P
><P
>If the number of registrations from <CODE
CLASS="varname"
>start</CODE
> is fewer than <CODE
CLASS="varname"
>ndev</CODE
>, all remaining registrations are stored. A value passed in return code less than or equal to <CODE
CLASS="varname"
>ndev</CODE
> means all remaining registrations were obtained. Note that this numbering changes as devices are registered and deleted. For this reason, accurate information may not be always obtained if the acquisition is carried out over multiple operations.</P
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="tk_evt_dev"
>tk_evt_dev - Send Driver Request Event to Device</A
></H3
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21952"
>C Language Interface</A
></H4
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN21954"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT retcode = tk_evt_dev</CODE
>(ID devid, INT evttyp, void *evtinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21965"
>Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21967"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Event destination device ID</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evttyp</CODE
>
              </TD
><TD
>Event Type</TD
><TD
>Driver request event type</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evtinf</CODE
>
              </TD
><TD
>Event Information</TD
><TD
>Information for each event type</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN21992"
>Return Parameter</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN21994"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>retcode</CODE
>
              </TD
><TD
>Return Code from eventfn</TD
><TD
>Return code passed by <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
></TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN22012"
>Error Code</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22014"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>The device specified in <CODE
CLASS="varname"
>devid</CODE
> does not exist</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_PAR</SPAN
>
              </TD
><TD
>Internal device manager events (<CODE
CLASS="varname"
>evttyp</CODE
> &#60; 0) cannot be specified</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN22033"
>Valid Context</A
></H4
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22035"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN22050"
>Related Service Profile Items</A
></H4
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="AEN22053"
>Description</A
></H4
><P
>Sends a driver request event to the device (device driver) specified in <CODE
CLASS="varname"
>devid</CODE
>.</P
><P
>The functioning of driver request events and the contents of <CODE
CLASS="varname"
>evtinf</CODE
> are defined for each event type. For details on driver request event, see <A
HREF="device_management_functions.html#eventfn"
>the Section called <I
>eventfn - Event function</I
></A
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="registration_of_device_driver"
>Registration of Device Driver</A
></H2
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="device_registration_device_management"
>Registration Method of Device Driver</A
></H3
><P
>Device driver registration is performed for each physical device.</P
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="tk_def_dev"
>tk_def_dev - Register Device</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22067"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22069"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ID devid = tk_def_dev</CODE
>(CONST UB *devnm, CONST T_DDEV *ddev, T_IDEV *idev);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22080"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22082"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="21%"><COL
WIDTH="14%"><COL
WIDTH="29%"><COL
WIDTH="36%"><TBODY
VALIGN="top"
><TR
><TD
>CONST UB*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devnm</CODE
>
              </TD
><TD
>Physical Device Name</TD
><TD
>Physical device name</TD
></TR
><TR
><TD
>CONST T_DDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ddev</CODE
>
              </TD
><TD
>Define Device</TD
><TD
>Device registration information</TD
></TR
><TR
><TD
>T_IDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>idev</CODE
>
              </TD
><TD
>Initial Device Information</TD
><TD
>Device initial information</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22107"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22109"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="21%"
TITLE="c1"><COL
WIDTH="14%"
TITLE="c2"><COL
WIDTH="29%"
TITLE="c3"><COL
WIDTH="36%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
><CODE
CLASS="varname"
>idev</CODE
> Detail:</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22128"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="21%"
TITLE="c1"><COL
WIDTH="14%"><COL
WIDTH="29%"><COL
WIDTH="36%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evtmbfid</CODE
>
              </TD
><TD
>Event Notification Message Buffer ID</TD
><TD
>Event notification message buffer ID</TD
></TR
><TR
><TD
COLSPAN="4"
>(Other implementation-dependent parameters may be added beyond this point.)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22143"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22145"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_LIMIT</SPAN
>
              </TD
><TD
>Number of registrations exceeds the system limit</TD
></TR
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_NOEXS</SPAN
>
              </TD
><TD
>The device specified in <CODE
CLASS="varname"
>devnm</CODE
> does not exist (when <CODE
CLASS="varname"
>ddev</CODE
> = <TT
CLASS="literal"
>NULL</TT
>)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22161"
>Valid Context</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22163"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22178"
>Related Service Profile Items</A
></H5
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22181"
>Description</A
></H5
><P
>Registers a device (device driver) with the device name set in <CODE
CLASS="varname"
>devnm</CODE
>, and passes the device ID of the registered device in the return code. If a device with device name <CODE
CLASS="varname"
>devnm</CODE
> is already registered, the registration is updated with new information, in which case the device ID does not change.</P
><P
><CODE
CLASS="varname"
>ddev</CODE
> specifies the device registration information. When <CODE
CLASS="varname"
>ddev</CODE
> = <TT
CLASS="literal"
>NULL</TT
> is specified, device <CODE
CLASS="varname"
>devnm</CODE
> registration is deleted.</P
><P
><CODE
CLASS="varname"
>ddev</CODE
> is a structure in the following format:
<PRE
CLASS="programlisting"
>&#13;typedef struct t_ddev {
        void    *exinf;   /* extended information */
        ATR     drvatr;   /* driver attributes */
        ATR     devatr;   /* device attributes */
        INT     nsub;     /* number of subunits */
        SZ      blksz;    /* block size of device-specific data (-1: unknown) */
        FP      openfn;   /* open function */
        FP      closefn;  /* close function */
        FP      execfn;   /* execute function */
        FP      waitfn;   /* wait-for-completion function */
        FP      abortfn;  /* abort function */
        FP      eventfn;  /* event function */
        /* Implementation-dependent information may be added beyond this point.*/
} T_DDEV;
</PRE
>
</P
><P
><CODE
CLASS="varname"
>exinf</CODE
> is used to store any desired information. The value is passed to the processing functions. Device management pays no attention to the contents.</P
><P
><CODE
CLASS="varname"
>drvatr</CODE
> sets device driver attribute information. The lower bits indicate system attributes, and the high bits are used for implementation-dependent attributes. The implementation-dependent attribute portion is used, for example, to define validity flags when implementation-dependent data is added to T_DDEV.
<PRE
CLASS="synopsis"
>&#13;drvatr := [TDA_OPENREQ] | [TDA_TMO_U] | [TDA_DEV_D]
</PRE
>


<PRE
CLASS="programlisting"
>&#13;#define TDA_OPENREQ     0x0001  /* open/close each time */
#define TDA_TMO_U       0x0002  /* timeout in microseconds is used */
#define TDA_DEV_D       0x0004  /* 64 bit device */
</PRE
>
</P
><P
><CODE
CLASS="varname"
>drvatr</CODE
> can be specified by combining the following driver attributes.</P
><P
>&#13;        <TT
CLASS="literal"
>TDA_OPENREQ</TT
>
      </P
><P
>When a device is opened multiple times, normally <A
HREF="device_management_functions.html#openfn"
>openfn</A
> is called only the first time it is opened and <A
HREF="device_management_functions.html#closefn"
>closefn</A
> the last time it is closed. If <TT
CLASS="literal"
>TDA_OPENREQ</TT
> is specified, then <A
HREF="device_management_functions.html#openfn"
>openfn</A
>/<A
HREF="device_management_functions.html#closefn"
>closefn</A
> will be called for all open/close operations even in case of multiple openings.</P
><P
>&#13;        <TT
CLASS="literal"
>TDA_TMO_U</TT
>
      </P
><P
>Indicates that timeout in microseconds is used.</P
><P
>In this case, the timeout <CODE
CLASS="varname"
>tmout</CODE
> of driver processing functions is specified in the TMO_U format (microseconds).</P
><P
>&#13;        <TT
CLASS="literal"
>TDA_DEV_D</TT
>
      </P
><P
>Indicates that a 64-bit device is used. In this case, the type of the request packet <CODE
CLASS="varname"
>devreq</CODE
> of driver processing functions is T_DEVREQ_D.</P
><P
>If <TT
CLASS="literal"
>TDA_TMO_U</TT
> or <TT
CLASS="literal"
>TDA_DEV_D</TT
> is specified, type of some parameters of driver processing functions is changed. If a combination of multiple driver attributes that change the type of parameters is specified in a driver processing function, the type of all specified parameters of that function is changed.</P
><P
>Device attributes are specified in <CODE
CLASS="varname"
>devatr</CODE
>. The details of device attribute setting are as noted above.</P
><P
>The number of subunits is set in <CODE
CLASS="varname"
>nsub</CODE
>. If there are no subunits, 0 is specified.</P
><P
><CODE
CLASS="varname"
>blksz</CODE
> sets the block size of device-specific data in bytes. In the case of a disk device, this is the physical block size. It is set to 1 byte for a serial port, etc. For a device with no device-specific data, it is set to 0. For an unformatted disk or other device whose block size is unknown, -1 is set. If <CODE
CLASS="varname"
>blksz</CODE
> ≦ 0, device-specific data cannot be accessed. When device-specific data is accessed by <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> or <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>, <CODE
CLASS="varname"
>size</CODE
> * <CODE
CLASS="varname"
>blksz</CODE
> must be the size of the area being accessed, that is, the size of <CODE
CLASS="varname"
>buf</CODE
>.</P
><P
><A
HREF="device_management_functions.html#openfn"
>openfn</A
>, <A
HREF="device_management_functions.html#closefn"
>closefn</A
>, <A
HREF="device_management_functions.html#execfn"
>execfn</A
>, <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>, and <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
> set the entry address of driver processing functions. For more details on driver processing functions, see <A
HREF="device_management_functions.html#device_driver_interface_device_management"
>the Section called <I
>Device Driver Interface</I
></A
>.</P
><P
>The device initialization information is returned in <CODE
CLASS="varname"
>idev</CODE
>. This includes information set by default when the device driver is started, and can be used as necessary. When <CODE
CLASS="varname"
>idev</CODE
> = <TT
CLASS="literal"
>NULL</TT
> is set, device initialization information is not stored.</P
><P
><CODE
CLASS="varname"
>evtmbfid</CODE
> specifies the system default message buffer ID for event notification. If there is no system default event notification message buffer, 0 is set.</P
><P
>Notification like the following is made to each subsystem when a device is registered or deleted. <CODE
CLASS="varname"
>devid</CODE
> is the device ID of the registered or deleted physical device.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Device registration or update:</DT
><DD
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_DEVICE_REGIST</TT
>, <CODE
CLASS="varname"
>devid</CODE
>)</P
></DD
><DT
>Device deletion:</DT
><DD
><P
><A
HREF="subsystem_management_functions.html#tk_evt_ssy"
>tk_evt_ssy</A
>(0, <TT
CLASS="literal"
>TSEVT_DEVICE_DELETE</TT
>, <CODE
CLASS="varname"
>devid</CODE
>)</P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="tk_ref_idv"
>tk_ref_idv - Reference Device Initialization Information</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22267"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22269"
></A
><PRE
CLASS="funcsynopsisinfo"
>#include &#60;tk/tkernel.h&#62;</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = tk_ref_idv</CODE
>(T_IDEV *idev);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22276"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22278"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>T_IDEV*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>idev</CODE
>
              </TD
><TD
>Packet to Return Initial Device Information</TD
><TD
>Pointer to the area to return the device initialization information</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22291"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22293"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
><CODE
CLASS="varname"
>idev</CODE
> Detail:</P
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22308"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evtmbfid</CODE
>
              </TD
><TD
>Event Notification Message Buffer ID</TD
><TD
>Event notification message buffer ID</TD
></TR
><TR
><TD
COLSPAN="4"
>(Other implementation-dependent parameters may be added beyond this point.)</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22323"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22325"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>E_MACV</SPAN
>
              </TD
><TD
>Memory access privilege error</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22334"
>Valid Context</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22336"
></A
><TABLE
BORDER="1"
FRAME="border"
RULES="all"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="33%"><COL
WIDTH="33%"><COL
WIDTH="33%"><THEAD
><TR
><TH
ALIGN="center"
>Task portion</TH
><TH
ALIGN="center"
>Quasi-task portion</TH
><TH
ALIGN="center"
>Task-independent portion</TH
></TR
></THEAD
><TBODY
VALIGN="top"
><TR
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>YES</TD
><TD
ALIGN="center"
>NO</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22351"
>Related Service Profile Items</A
></H5
><P
>None.</P
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22354"
>Description</A
></H5
><P
>Gets device initialization information. The contents are the same as the information obtained by <A
HREF="device_management_functions.html#tk_def_dev"
>tk_def_dev</A
>.</P
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22358"
>Additional Notes</A
></H5
><P
>The error code <SPAN
CLASS="errorname"
>E_MACV</SPAN
> is common to many system calls, and usually not included in the error code list of each system call. However, for this API, <SPAN
CLASS="errorname"
>E_MACV</SPAN
> is included in this error code list because it is the only typical error.</P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="device_driver_interface_device_management"
>Device Driver Interface</A
></H3
><P
>The device driver interface consists of processing functions (driver processing functions) specified when registering a device.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Open function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#openfn"
>openfn</A
>(ID <CODE
CLASS="varname"
>devid</CODE
>, UINT <CODE
CLASS="varname"
>omode</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Close function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#closefn"
>closefn</A
>(ID <CODE
CLASS="varname"
>devid</CODE
>, UINT <CODE
CLASS="varname"
>option</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Execute function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#execfn"
>execfn</A
>(T_DEVREQ *<CODE
CLASS="varname"
>devreq</CODE
>, TMO <CODE
CLASS="varname"
>tmout</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Wait-for-completion function</DT
><DD
><P
>INT <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>(T_DEVREQ *<CODE
CLASS="varname"
>devreq</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, TMO <CODE
CLASS="varname"
>tmout</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Abort function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>(ID <CODE
CLASS="varname"
>tskid</CODE
>, T_DEVREQ *<CODE
CLASS="varname"
>devreq</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Event function</DT
><DD
><P
>INT <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
>(INT <CODE
CLASS="varname"
>evttyp</CODE
>, void *<CODE
CLASS="varname"
>evtinf</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
></DL
></DIV
><P
>If <TT
CLASS="literal"
>TDA_TMO_U</TT
> is specified for a driver attribute, the timeout specification <CODE
CLASS="varname"
>tmout</CODE
> for the following driver processing functions is set to TMO_U type (in microseconds).</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Execute function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#execfn"
>execfn</A
>(T_DEVREQ *<CODE
CLASS="varname"
>devreq</CODE
>, TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Wait-for-completion function</DT
><DD
><P
>INT <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>(T_DEVREQ *<CODE
CLASS="varname"
>devreq</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
></DL
></DIV
><P
>If <TT
CLASS="literal"
>TDA_DEV_D</TT
> is specified for a driver attribute, the type of request packet <CODE
CLASS="varname"
>devreq</CODE
> for the following driver processing functions is set to T_DEVREQ_D.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Execute function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#execfn"
>execfn</A
>(T_DEVREQ_D *<CODE
CLASS="varname"
>devreq_d</CODE
>, TMO <CODE
CLASS="varname"
>tmout</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Wait-for-completion function</DT
><DD
><P
>INT <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>(T_DEVREQ_D *<CODE
CLASS="varname"
>devreq_d</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, TMO <CODE
CLASS="varname"
>tmout</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Abort function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>(ID <CODE
CLASS="varname"
>tskid</CODE
>, T_DEVREQ_D *<CODE
CLASS="varname"
>devreq_d</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
></DL
></DIV
><P
>If <TT
CLASS="literal"
>TDA_TMO_U</TT
> and <TT
CLASS="literal"
>TDA_DEV_D</TT
> are specified set a driver attribute, a driver processing function is set to the one that has parameters with all the specified types of changes were applied.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>Execute function</DT
><DD
><P
>ER <A
HREF="device_management_functions.html#execfn"
>execfn</A
>(T_DEVREQ_D *<CODE
CLASS="varname"
>devreq_d</CODE
>, TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
><DT
>Wait-for-completion function</DT
><DD
><P
>INT <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>(T_DEVREQ_D *<CODE
CLASS="varname"
>devreq_d</CODE
>, INT <CODE
CLASS="varname"
>nreq</CODE
>, TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>, void *<CODE
CLASS="varname"
>exinf</CODE
>);</P
></DD
></DL
></DIV
><P
>Driver processing functions are called by device management and run as a quasi-task portion. These driver processing functions must be reentrant. Calling of these driver processing functions in a mutually exclusive manner is not guaranteed. If, for example, there are simultaneous requests from multiple devices for the same device, different tasks might call the same driver processing function at the same time. The device driver must perform mutual exclusion control in such cases as necessary.</P
><P
>I/O requests to a device driver are made by means of the following request packet associated with a request ID.</P
><PRE
CLASS="programlisting"
>&#13;/*
 * Device request packet: For 32-bit
 * In:  Input parameter to driver processing function (set in μT-Kernel/SM device management)
 * Out: Output parameter from driver processing function (set in driver processing function)
 * X:   Parameters other than input and output
 */
typedef struct t_devreq {
        struct t_devreq *next;    /* In: Link to request packet (NULL: termination) */
        void    *exinf;           /* X: Extended information */
        ID      devid;            /* In: Target device ID */
        INT     cmd:4;            /* In: Request command */
        BOOL    abort:1;          /* In: TRUE if abort request */
        W       start;            /* In: Starting data number */
        SZ      size;             /* In: Request size */
        void    *buf;             /* In: IO buffer address */
        SZ      asize;            /* Out: Size of result */
        ER      error;            /* Out: Error result */
        /* Implementation-dependent information may be added beyond this point.*/
} T_DEVREQ;
</PRE
><PRE
CLASS="programlisting"
>&#13;/*
 * Device request packet: For 64-bit
 * In:  Input parameter to driver processing function (set in μT-Kernel/SM device management)
 * Out: Output parameter from driver processing function (set in driver processing function)
 * X:   Parameters other than input and output
 */
typedef struct t_devreq_d {
        struct t_devreq_d *next;  /* In: Link to request packet (NULL: termination) */
        void    *exinf;           /* X: Extended information */
        ID      devid;            /* In: Target device ID */
        INT     cmd:4;            /* In: Request command */
        BOOL    abort:1;          /* In: TRUE if abort request */
        D       start_d;          /* In: Starting data number, 64-bit */
        SZ      size;             /* In: Request size */
        void    *buf;             /* In: IO buffer address */
        SZ      asize;            /* Out: Size of result */
        ER      error;            /* Out: Error result */
        /* Implementation-dependent information may be added beyond this point.*/
} T_DEVREQ_D;
</PRE
><P
>In: Input parameter to the driver processing function is set in μT-Kernel/SM device management. Should not be changed on the device driver side. Parameters other than input parameters (In) are initially cleared to 0 by the device management. After that, device management does not modify them. Out: Output parameter returned from the driver execute function is set in the driver processing function.</P
><P
><CODE
CLASS="varname"
>next</CODE
> is used to link the request packet. In addition to usage for keeping track of request packets in device management, it is used also by the completion wait function (<A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>) and abort function (<A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>).</P
><P
><CODE
CLASS="varname"
>exinf</CODE
> can be used freely by the device driver. Device management does not pay attention to the contents.</P
><P
>The device ID of the device to which the request is issued is specified in <CODE
CLASS="varname"
>devid</CODE
>.</P
><P
>The request command is specified in <CODE
CLASS="varname"
>cmd</CODE
> as follows.
<PRE
CLASS="synopsis"
>&#13;cmd := (TDC_READ || TDC_WRITE)
</PRE
>


<PRE
CLASS="programlisting"
>&#13;#define TDC_READ        1       /* read request */
#define TDC_WRITE       2       /* write request */
</PRE
>
</P
><P
>If abort processing is to be carried out, <CODE
CLASS="varname"
>abort</CODE
> is set to <TT
CLASS="literal"
>TRUE</TT
> right before calling the abort function (<A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>). <CODE
CLASS="varname"
>abort</CODE
> is a flag indicating whether abort processing was requested, and does not indicate that processing was aborted. In some cases <CODE
CLASS="varname"
>abort</CODE
> is set to <TT
CLASS="literal"
>TRUE</TT
> even when the abort function (<A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>) is not called. Abort processing is performed when a request with <CODE
CLASS="varname"
>abort</CODE
> set to <TT
CLASS="literal"
>TRUE</TT
> is actually passed to the device driver.</P
><P
><CODE
CLASS="varname"
>start</CODE
>, <CODE
CLASS="varname"
>start_d</CODE
>, and <CODE
CLASS="varname"
>size</CODE
> are just set as <CODE
CLASS="varname"
>start</CODE
>, <CODE
CLASS="varname"
>start_d</CODE
>, and <CODE
CLASS="varname"
>size</CODE
> specified in <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>, <A
HREF="device_management_functions.html#tk_rea_dev_du"
>tk_rea_dev_du</A
>, <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>, and <A
HREF="device_management_functions.html#tk_wri_dev_du"
>tk_wri_dev_du</A
>.</P
><P
><CODE
CLASS="varname"
>buf</CODE
> is just set as <CODE
CLASS="varname"
>buf</CODE
> specified in <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>, <A
HREF="device_management_functions.html#tk_rea_dev_du"
>tk_rea_dev_du</A
>, <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>, and <A
HREF="device_management_functions.html#tk_wri_dev_du"
>tk_wri_dev_du</A
>. On systems that support virtual memory, the memory space specified in <CODE
CLASS="varname"
>buf</CODE
> may be nonresident or belong to task space, so care must be taken to handle such cases.</P
><P
>The device driver sets in <CODE
CLASS="varname"
>asize</CODE
> the value returned in <CODE
CLASS="varname"
>asize</CODE
> by <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>.</P
><P
>The device driver sets in <CODE
CLASS="varname"
>error</CODE
> the error code passed by <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> in its return code. <SPAN
CLASS="errorname"
>E_OK</SPAN
> indicates a normal result.</P
><P
>Difference between T_DEVREQ and T_DEVREQ_D is only the part of their names being <CODE
CLASS="varname"
>start</CODE
> or <CODE
CLASS="varname"
>start_d</CODE
>, and the data type.</P
><P
>The type of device request packet (T_DEVREQ or T_DEVREQ_D) is selected based on the driver attribute (<TT
CLASS="literal"
>TDA_DEV_D</TT
>) at device registration. For this reason, T_DEVREQ and T_DEVRE do not co-exist in the request packet for one driver.</P
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="openfn"
>openfn - Open function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22550"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22552"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = openfn</CODE
>(ID devid, UINT omode, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22562"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22564"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID of the device to open</TD
></TR
><TR
><TD
>UINT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>omode</CODE
>
              </TD
><TD
>Open Mode</TD
><TD
>Open mode (same as <A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
>)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22590"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22592"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22605"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22607"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22616"
>Description</A
></H5
><P
>The open function <A
HREF="device_management_functions.html#openfn"
>openfn</A
> is called when <A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
> is invoked.</P
><P
>The function <A
HREF="device_management_functions.html#openfn"
>openfn</A
> performs processing to enable use of a device. Details of the processing are device-dependent; if no processing is needed, it does nothing. The device driver does not need to remember whether a device is open or not, nor is it necessary to treat as error the calling of another processing function simply because the device was not opened (<A
HREF="device_management_functions.html#openfn"
>openfn</A
> had not been called). If another processing function is called for a device that is not open, the necessary processing can be performed so long as there is no problem in device driver operation.</P
><P
>When <A
HREF="device_management_functions.html#openfn"
>openfn</A
> is used to perform device initialization or the like, in principle no processing should be performed that causes a wait. The processing and return from <A
HREF="device_management_functions.html#openfn"
>openfn</A
> must be as prompt as possible. In the case of a device such as a serial port for which it is necessary to set the communication mode, for example, the device can be initialized when the communication mode is set by <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>. There is no need for <A
HREF="device_management_functions.html#openfn"
>openfn</A
> to initialize the device.</P
><P
>When the same device is opened multiple times, normally this function is called only for the first time. If, however, the driver attribute <TT
CLASS="literal"
>TDA_OPENREQ</TT
> is specified in device registration, this function is called each time the device is opened.</P
><P
>The <A
HREF="device_management_functions.html#openfn"
>openfn</A
> function does not need to perform any processing with regard to multiple opening or open mode, which are handled by device management. Likewise, <CODE
CLASS="varname"
>omode</CODE
> is simply passed as reference information; no processing relating to <CODE
CLASS="varname"
>omode</CODE
> is required.</P
><P
><A
HREF="device_management_functions.html#openfn"
>openfn</A
> runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
>. That is, it is executed in the context of the quasi-task portion whose requesting task is the task that issued <A
HREF="device_management_functions.html#tk_opn_dev"
>tk_opn_dev</A
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="closefn"
>closefn - Close function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22641"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22643"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = closefn</CODE
>(ID devid, UINT option, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22653"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22655"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devid</CODE
>
              </TD
><TD
>Device ID</TD
><TD
>Device ID of the device to close</TD
></TR
><TR
><TD
>UINT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>option</CODE
>
              </TD
><TD
>Close Option</TD
><TD
>Close option (same as <A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
>)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22681"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22683"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22696"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22698"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22707"
>Description</A
></H5
><P
>The close function <A
HREF="device_management_functions.html#closefn"
>closefn</A
> is called when <A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
> is invoked.</P
><P
>The <A
HREF="device_management_functions.html#closefn"
>closefn</A
> function performs processing to end use of a device. Details of the processing are device-dependent; if no processing is needed, it does nothing.</P
><P
>If the device is capable of ejecting media and <TT
CLASS="literal"
>TD_EJECT</TT
> is set in <CODE
CLASS="varname"
>option</CODE
>, media ejection is performed.</P
><P
>When <A
HREF="device_management_functions.html#closefn"
>closefn</A
> is used to perform device shutdown processing or media ejection, in principle no processing should be performed that causes a wait. The processing and return from <A
HREF="device_management_functions.html#closefn"
>closefn</A
> must be as prompt as possible. If media ejection takes time, it is permissible to return from <A
HREF="device_management_functions.html#closefn"
>closefn</A
> without waiting for the ejection to complete.</P
><P
>When the same device is opened multiple times, normally this function is called only the last time it is closed. If, however, the driver attribute <TT
CLASS="literal"
>TDA_OPENREQ</TT
> is specified in device registration, this function is called each time the device is closed. In this case <TT
CLASS="literal"
>TD_EJECT</TT
> is specified in <CODE
CLASS="varname"
>option</CODE
> only for the last time.</P
><P
>The <A
HREF="device_management_functions.html#closefn"
>closefn</A
> function does not need to perform any processing with regard to multiple opening or open mode, which are handled by device management.</P
><P
><A
HREF="device_management_functions.html#closefn"
>closefn</A
> runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="execfn"
>execfn - Execute function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22732"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22734"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* Execute function (32-bit request packet, millisecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = execfn</CODE
>(T_DEVREQ *devreq, TMO tmout, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22745"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* execute function (64-bit request packet, millisecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = execfn</CODE
>(T_DEVREQ_D *devreq_d, TMO tmout, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22756"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* execute function (32-bit request packet, microsecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = execfn</CODE
>(T_DEVREQ *devreq, TMO_U tmout_u, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22767"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* execute function (64-bit request packet, microsecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = execfn</CODE
>(T_DEVREQ_D *devreq_d, TMO_U tmout_u, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22778"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22780"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>T_DEVREQ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet (32-bit)</TD
></TR
><TR
><TD
>T_DEVREQ_D*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq_d</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet (64-bit)</TD
></TR
><TR
><TD
>TMO</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (ms)</TD
></TR
><TR
><TD
>TMO_U</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout_u</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Request acceptance timeout (in microseconds)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22817"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22819"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22832"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22834"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22843"
>Description</A
></H5
><P
>The execute function <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is called when <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> or <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
> is invoked.</P
><P
>Initiates the processing requested in <CODE
CLASS="varname"
>devreq</CODE
>. This function initiates the requested processing only, returning to its caller without waiting for the processing to complete. The time required to initiate processing depends on the device driver; this function does not necessarily complete immediately.</P
><P
>When new processing cannot be accepted, this function goes to WAITING state for request acceptance. If the new request cannot be accepted within the time specified in <CODE
CLASS="varname"
>tmout</CODE
>, the function times out. The <TT
CLASS="literal"
>TMO_POL</TT
> or <TT
CLASS="literal"
>TMO_FEVR</TT
> attribute can be specified in <CODE
CLASS="varname"
>tmout</CODE
>. If the function times out, <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
> is passed in the <A
HREF="device_management_functions.html#execfn"
>execfn</A
> return code. The request packet <CODE
CLASS="varname"
>error</CODE
> parameter does not change. Timeout applies to the request acceptance, not to the processing after acceptance.</P
><P
>When error is passed in the <A
HREF="device_management_functions.html#execfn"
>execfn</A
> return code, the request is considered not to have been accepted and the request packet is discarded.</P
><P
>If processing is aborted before the request is accepted (before the requested processing starts), <SPAN
CLASS="errorname"
>E_ABORT</SPAN
> is passed in the <A
HREF="device_management_functions.html#execfn"
>execfn</A
> return code. In this case, the request packet is discarded. If the abort occurs after the processing has been accepted, <SPAN
CLASS="errorname"
>E_OK</SPAN
> is returned for this function. The request packet is not discarded until <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is executed and processing completes.</P
><P
>When abort occurs, the important thing is to return from <A
HREF="device_management_functions.html#execfn"
>execfn</A
> as quickly as possible. If processing will end soon anyway without aborting, it is not necessary to abort.</P
><P
><A
HREF="device_management_functions.html#execfn"
>execfn</A
> runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
>, <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
>, <A
HREF="device_management_functions.html#tk_srea_dev"
>tk_srea_dev</A
>, or <A
HREF="device_management_functions.html#tk_swri_dev"
>tk_swri_dev</A
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_DEV_D</TT
> is specified as an attribute at the time of registering the device, the execute function (64-bit request packet, millisecond timeout) <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is called when <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> or <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#execfn"
>execfn</A
>, except that the parameter request packet is a 64-bit T_DEVREQ_D* <CODE
CLASS="varname"
>devreq_d</CODE
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_TMO_U</TT
> is specified as an attribute at the time of registering the device, the execute function (32-bit request packet, microsecond timeout) <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is called when <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> or <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#execfn"
>execfn</A
>, except that the parameter timeout specification is a microsecond TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>.</P
><P
>In a device driver for which both <TT
CLASS="literal"
>TDA_DEV_D</TT
> and <TT
CLASS="literal"
>TDA_TMO_U</TT
> are specified as an attribute at the time of registering the device, the execute function (64-bit request packet, microsecond timeout) <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is called when <A
HREF="device_management_functions.html#tk_rea_dev"
>tk_rea_dev</A
> or <A
HREF="device_management_functions.html#tk_wri_dev"
>tk_wri_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#execfn"
>execfn</A
>, except that the parameter request packet is a 64-bit T_DEVREQ_D* <CODE
CLASS="varname"
>devreq_d</CODE
> and the parameter timeout specification is a microsecond TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="waitfn"
>waitfn - Wait-for-completion function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22899"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22901"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* wait-for-completion function (32-bit request packet, millisecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT creqno = waitfn</CODE
>(T_DEVREQ *devreq, INT nreq, TMO tmout, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22914"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* wait-for-completion function (64-bit request packet, millisecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT creqno = waitfn</CODE
>(T_DEVREQ_D *devreq_d, INT nreq, TMO tmout, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22927"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* wait-for-completion function (32-bit request packet, microsecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT creqno = waitfn</CODE
>(T_DEVREQ *devreq, INT nreq, TMO_U tmout_u, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN22940"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* wait-for-completion function (64-bit request packet, microsecond timeout) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT creqno = waitfn</CODE
>(T_DEVREQ_D *devreq_d, INT nreq, TMO_U tmout_u, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22953"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN22955"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>T_DEVREQ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet list (32-bit)</TD
></TR
><TR
><TD
>T_DEVREQ_D*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq_d</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet list (64-bit)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>nreq</CODE
>
              </TD
><TD
>Number of Requests</TD
><TD
>Request packet count</TD
></TR
><TR
><TD
>TMO</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Timeout (ms)</TD
></TR
><TR
><TD
>TMO_U</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tmout_u</CODE
>
              </TD
><TD
>Timeout</TD
><TD
>Timeout (in microseconds)</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN22998"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23000"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>creqno</CODE
>
              </TD
><TD
>Completed Request Packet Number</TD
><TD
>Completed request packet number</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23017"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23019"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23028"
>Description</A
></H5
><P
>The wait-for-completion function <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called when <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> is invoked.</P
><P
><CODE
CLASS="varname"
>devreq</CODE
> is a list of request packets in a chain linked by <CODE
CLASS="varname"
>devreq</CODE
>-&#62;<CODE
CLASS="varname"
>next</CODE
>. This function waits for completion of any of the <CODE
CLASS="varname"
>nreq</CODE
> request packets starting from <CODE
CLASS="varname"
>devreq</CODE
>. The final <CODE
CLASS="varname"
>next</CODE
> is not necessarily <TT
CLASS="literal"
>NULL</TT
>, so the <CODE
CLASS="varname"
>nreq</CODE
> must always be followed. The number of the completed request packet (which one after <CODE
CLASS="varname"
>devreq</CODE
>) is passed in the return code. The first one is numbered 0 and the last one is numbered <CODE
CLASS="varname"
>nreq</CODE
> - 1. Here completion means any of normal completion, abnormal (error) termination, or abort.</P
><P
>The timeout for waiting for completion is set in <CODE
CLASS="varname"
>tmout</CODE
>. The <TT
CLASS="literal"
>TMO_POL</TT
> or <TT
CLASS="literal"
>TMO_FEVR</TT
> attribute can be specified for <CODE
CLASS="varname"
>tmout</CODE
>. If the wait times out, the requested processing continues. The <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code in case of timeout is <SPAN
CLASS="errorname"
>E_TMOUT</SPAN
>. The request packet <CODE
CLASS="varname"
>error</CODE
> parameter does not change. Note that if return from <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> occurs while the requested processing continues, error must be returned in the <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code; but the processing must not be completed when error is passed in the return code, and a value other than error must not be returned if processing is ongoing. As long as error is passed in the <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code, the request is considered to be pending and no request packet is discarded. When the number of a request packet whose processing was completed is passed in the <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code, the processing of that request is considered to be completed and that request packet is discarded.</P
><P
>I/O error and other device-related errors are stored in the request packet <CODE
CLASS="varname"
>error</CODE
> parameter. Error is passed in the <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code when completion waiting did not take place properly. The <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> return code is set in the <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> return code, whereas the request packet <CODE
CLASS="varname"
>error</CODE
> value is returned in <CODE
CLASS="varname"
>ioer</CODE
>.</P
><P
>The abort processing when the abort function <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> was executed during completion waiting by <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> differs depending on whether to wait for completion of a single request (<A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, <CODE
CLASS="varname"
>nreq</CODE
> = 1) or multiple requests (<A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, <CODE
CLASS="varname"
>nreq</CODE
> &#62; 1). When waiting for completion of a single request, the request currently processing is aborted. On the other hand, when waiting for completion of multiple requests, as a special handling, only the completion waiting by <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is released and the processing for the request itself is not aborted. It means that, even if the abort function <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is executed, the request packets' <CODE
CLASS="varname"
>abort</CODE
> remains <TT
CLASS="literal"
>FALSE</TT
> and the processing for the requests continues. <SPAN
CLASS="errorname"
>E_ABORT</SPAN
> is passed in the return code from the released <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>.</P
><P
>During a wait for request completion, an abort request may be set in the <CODE
CLASS="varname"
>abort</CODE
> parameter of a request packet. In such a case, if it is a single request, the request abort processing must be performed. If the wait is for multiple requests it is also preferable that abort processing be executed, but it is also possible to ignore the <CODE
CLASS="varname"
>abort</CODE
> flag.</P
><P
>When abort occurs, the important thing is to return from <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> as quickly as possible. If processing will end soon anyway without aborting, it is not necessary to abort.</P
><P
>As a rule, <SPAN
CLASS="errorname"
>E_ABORT</SPAN
> is returned in the request packet <CODE
CLASS="varname"
>error</CODE
> parameter when processing is aborted; but a different error code than <SPAN
CLASS="errorname"
>E_ABORT</SPAN
> may be returned as appropriate based on the device properties. It is also permissible to return <SPAN
CLASS="errorname"
>E_OK</SPAN
> on the basis that the processing right up to the abort is valid. If processing completes normally to the end, <SPAN
CLASS="errorname"
>E_OK</SPAN
> is returned even if there was an abort request.</P
><P
><A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
>, <A
HREF="device_management_functions.html#tk_srea_dev"
>tk_srea_dev</A
>, or <A
HREF="device_management_functions.html#tk_swri_dev"
>tk_swri_dev</A
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_DEV_D</TT
> is specified as an attribute at the time of registering the device, the wait-for-completion function (64-bit request packet, millisecond timeout) <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called when <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, except that the parameter request packet is a 64-bit T_DEVREQ_D* <CODE
CLASS="varname"
>devreq_d</CODE
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_TMO_U</TT
> is specified as an attribute at the time of registering the device, the wait-for-completion function (32-bit request packet, microsecond timeout) <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called when <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, except that the parameter timeout specification is a microsecond TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_DEV_D</TT
> and <TT
CLASS="literal"
>TDA_TMO_U</TT
> are specified as an attribute at the time of registering the device, the wait-for-completion function (64-bit request packet, microsecond timeout) <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called when <A
HREF="device_management_functions.html#tk_wai_dev"
>tk_wai_dev</A
> is invoked. In this case, the function specification is the same as that of 32-bit request packet, millisecond timeout <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, except that the parameter request packet is a 64-bit T_DEVREQ_D* <CODE
CLASS="varname"
>devreq_d</CODE
> and the parameter timeout specification is a microsecond TMO_U <CODE
CLASS="varname"
>tmout_u</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="abortfn"
>abortfn - Abort function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23114"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN23116"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* abort function (32-bit request packet) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = abortfn</CODE
>(ID tskid, T_DEVREQ *devreq, INT nreq, void *exinf);</CODE
></P
><P
></P
></DIV
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN23129"
></A
><PRE
CLASS="funcsynopsisinfo"
>/* abort function (64-bit request packet) */</PRE
><P
><CODE
><CODE
CLASS="FUNCDEF"
>ER ercd = abortfn</CODE
>(ID tskid, T_DEVREQ_D *devreq_d, INT nreq, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23142"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23144"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"><COL
WIDTH="15%"><COL
WIDTH="31%"><COL
WIDTH="38%"><TBODY
VALIGN="top"
><TR
><TD
>ID</TD
><TD
>&#13;                <CODE
CLASS="varname"
>tskid</CODE
>
              </TD
><TD
>Task ID</TD
><TD
>Task ID of the task executing <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
></TD
></TR
><TR
><TD
>T_DEVREQ*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet list (32-bit)</TD
></TR
><TR
><TD
>T_DEVREQ_D*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>devreq_d</CODE
>
              </TD
><TD
>Device Request Packet</TD
><TD
>Request packet list (64-bit)</TD
></TR
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>nreq</CODE
>
              </TD
><TD
>Number of Requests</TD
><TD
>Request packet count</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23183"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23185"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="15%"
TITLE="c1"><COL
WIDTH="15%"
TITLE="c2"><COL
WIDTH="31%"
TITLE="c3"><COL
WIDTH="38%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>ER</TD
><TD
>&#13;                <CODE
CLASS="varname"
>ercd</CODE
>
              </TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23198"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23200"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23209"
>Description</A
></H5
><P
>The abort function <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called when you want to promptly return from the currently running execute function <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or wait-for-completion function <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>. Normally this means the request being processed is aborted. If, however, the processing can be completed soon without aborting, it may not have to be aborted. The important thing is to return as quickly as possible from <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>.</P
><P
><A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called in the following cases.</P
><P
></P
><UL
><LI
><P
>When a break function is executing after a task exception and the task that raised the exception requests abort processing, abortfn is used to abort the request being processed by that task.</P
></LI
><LI
><P
>When a device is being closed by <A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
>, and the device descriptor was processing a request, abortfn is used to abort the request being processed by the device descriptor.</P
></LI
></UL
><P
><CODE
CLASS="varname"
>tskid</CODE
> indicates the task executing the request specified in <CODE
CLASS="varname"
>devreq</CODE
>. In other words, it is the task executing <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>. <CODE
CLASS="varname"
>devreq</CODE
> and <CODE
CLASS="varname"
>nreq</CODE
> are the same as the parameters that were passed to <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>. In the case of <A
HREF="device_management_functions.html#execfn"
>execfn</A
> , <CODE
CLASS="varname"
>nreq</CODE
> is always 1.</P
><P
><A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called by a different task from the one executing <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>. Since both tasks run concurrently, mutual exclusion control must be performed as necessary. It is possible that the <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> function will be called immediately before calling <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>, or during return from these functions.<A
HREF="device_management_functions.html#execfn"
></A
><A
HREF="device_management_functions.html#waitfn"
></A
> Measures must be taken to ensure proper operation in such cases. Before <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called, the <CODE
CLASS="varname"
>abort</CODE
> flag in the request packet whose processing is to be aborted is set to <TT
CLASS="literal"
>TRUE</TT
>, enabling <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> to know whether there is going to be an abort request. Note also that <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> can use <A
HREF="task_dependent_synchronization_functions.html#tk_dis_wai"
>tk_dis_wai</A
> for any object.</P
><P
>When <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is executing for multiple requests (<CODE
CLASS="varname"
>nreq</CODE
> &#62; 1), this is treated as a special case differing as follows from other cases.</P
><P
></P
><UL
><LI
><P
>Only the completion wait is aborted (waited is released), not the requested processing.</P
></LI
><LI
><P
>The <CODE
CLASS="varname"
>abort</CODE
> flag is not set in the request packet (remains as <CODE
CLASS="varname"
>abort</CODE
> = <TT
CLASS="literal"
>FALSE</TT
>).</P
></LI
></UL
><P
>Aborting a request when <A
HREF="device_management_functions.html#execfn"
>execfn</A
> and <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> are not executing is done not by calling <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> but by setting the request packet <CODE
CLASS="varname"
>abort</CODE
> flag. If <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is called when the <CODE
CLASS="varname"
>abort</CODE
> flag is set, the request is not accepted. If <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called, abort processing is the same as if <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called.</P
><P
>If a request for which processing was started by <A
HREF="device_management_functions.html#execfn"
>execfn</A
> is aborted before <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> was called to wait for its completion, the completion of the aborted processing is notified when <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
> is called later. Even though processing was aborted, the request itself is not discarded until its completion has been checked by <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>.</P
><P
><A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> initiates abort processing only, returning promptly without waiting for the abort to complete.</P
><P
>The <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> that is executed on a task exception runs as a quasi-task portion of the task issuing <A
HREF="task_exception_handling_functions.html#tk_ras_tex"
>tk_ras_tex</A
> that raised the task exception. The <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> that is executed on a device close runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_cls_dev"
>tk_cls_dev</A
>.</P
><P
>In a device driver for which <TT
CLASS="literal"
>TDA_DEV_D</TT
> is specified as an attribute at the time of registering the device, the abort function (64-bit request packet) <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
> is called when you want to promptly return from the currently running execute function <A
HREF="device_management_functions.html#execfn"
>execfn</A
> or wait-for-completion function <A
HREF="device_management_functions.html#waitfn"
>waitfn</A
>. In this case, the function specification is the same as that of 32-bit request packet <A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>, except that the parameter request packet is a 64-bit T_DEVREQ_D* <CODE
CLASS="varname"
>devreq_d</CODE
>.</P
></DIV
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="eventfn"
>eventfn - Event function</A
></H4
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23293"
>C Language Interface</A
></H5
><DIV
CLASS="funcsynopsis"
><P
></P
><A
NAME="AEN23295"
></A
><P
><CODE
><CODE
CLASS="FUNCDEF"
>INT retcode = eventfn</CODE
>(INT evttyp, void *evtinf, void *exinf);</CODE
></P
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23305"
>Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23307"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"><COL
WIDTH="17%"><COL
WIDTH="33%"><COL
WIDTH="42%"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evttyp</CODE
>
              </TD
><TD
>Event Type</TD
><TD
>Driver request event type</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>evtinf</CODE
>
              </TD
><TD
>Event Information</TD
><TD
>Information for each event type</TD
></TR
><TR
><TD
>void*</TD
><TD
>&#13;                <CODE
CLASS="varname"
>exinf</CODE
>
              </TD
><TD
>Extended Information</TD
><TD
>Extended information set at device registration</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23332"
>Return Parameter</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23334"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="8%"
TITLE="c1"><COL
WIDTH="17%"
TITLE="c2"><COL
WIDTH="33%"
TITLE="c3"><COL
WIDTH="42%"
TITLE="c4"><TBODY
VALIGN="top"
><TR
><TD
>INT</TD
><TD
>&#13;                <CODE
CLASS="varname"
>retcode</CODE
>
              </TD
><TD
>Return Code</TD
><TD
>Return code defined for each event type</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="right"
>or</TD
><TD
>Error Code</TD
><TD
>Error code</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23351"
>Error Code</A
></H5
><DIV
CLASS="informaltable"
><P
></P
><A
NAME="AEN23353"
></A
><TABLE
BORDER="0"
FRAME="void"
RULES="none"
WIDTH="100%"
CLASS="CALSTABLE"
><COL
WIDTH="17%"
TITLE="c1"><COL
WIDTH="83%"
TITLE="c2"><TBODY
VALIGN="top"
><TR
><TD
>&#13;                <SPAN
CLASS="errorname"
>Other</SPAN
>
              </TD
><TD
>Error code returned by the device driver</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23362"
>Description</A
></H5
><P
>When a state change occurs in the device or system which is caused by a factor other than normal device I/O processing by an application interface, requiring some processing by the device driver, a driver request event is raised and then the event function <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
> is called.</P
><P
>The driver request event is raised when suspending or resuming a device for power control (see <A
HREF="device_management_functions.html#tk_sus_dev"
>tk_sus_dev</A
>) or when connecting a removable device such as USB.</P
><P
>For example, when the system is suspended by <A
HREF="device_management_functions.html#tk_sus_dev"
>tk_sus_dev</A
>, the driver request event for the suspend (<TT
CLASS="literal"
>TDV_SUSPEND</TT
>) is raised in the μT-Kernel (during <A
HREF="device_management_functions.html#tk_sus_dev"
>tk_sus_dev</A
> processing) and the event function for each device is called with <CODE
CLASS="varname"
>evttyp</CODE
> = <TT
CLASS="literal"
>TDV_SUSPEND</TT
>. The event function called for each device performs necessary operations for suspend such as saving the state on receiving this driver request event.</P
><P
>The following driver request events are defined.</P
><PRE
CLASS="programlisting"
>&#13;#define TDV_SUSPEND   (-1)   /* suspend */
#define TDV_RESUME    (-2)   /* resume */
#define TDV_CARDEVT     1    /* reserved */
#define TDV_USBEVT      2    /* USB event */
</PRE
><P
>The driver request events with a negative value are called internally from the device management in the μT-Kernel/SM, for suspend or resume processing.</P
><P
>On the other hand, the driver request events with a positive value (<TT
CLASS="literal"
>TDV_USBEVT</TT
>) are reference specifications which are not directly related to the μT-Kernel operation, and raised by calling <A
HREF="device_management_functions.html#tk_evt_dev"
>tk_evt_dev</A
>. These driver request events are used as needed to implement a bus driver for USB or other device.</P
><P
>The processing performed by the event function is defined for each event type. For suspend and resume processings, see <A
HREF="device_management_functions.html#device_suspend_resume_processing_device_management"
>the Section called <I
>Device Suspend/Resume Processing</I
></A
>.</P
><P
>When a device event is called by <A
HREF="device_management_functions.html#tk_evt_dev"
>tk_evt_dev</A
>, the <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
> return code is set transparently as the <A
HREF="device_management_functions.html#tk_evt_dev"
>tk_evt_dev</A
> return code.</P
><P
>Requests to event functions must be accepted even if another request is processed, and must be processed as quickly as possible.</P
><P
>The <A
HREF="device_management_functions.html#eventfn"
>eventfn</A
> runs as a quasi-task portion of the task that issued <A
HREF="device_management_functions.html#tk_evt_dev"
>tk_evt_dev</A
> or <A
HREF="device_management_functions.html#tk_sus_dev"
>tk_sus_dev</A
> that caused the event.</P
></DIV
><DIV
CLASS="section"
><H5
CLASS="section"
><A
NAME="AEN23391"
>Additional Notes</A
></H5
><P
>The following behaviors are assumed for USB event.</P
><P
>Note that they describe implementation examples of device drivers that handle a device such as USB and are not part of the μT-Kernel specification.</P
><P
>When a USB device is connected, a class driver should dynamically be mapped to the USB device to perform an actual I/O processing.</P
><P
>For example, when a storage such as USB memory is connected, a device driver for the mass storage class handles the I/O for the device, or when a USB camera is connected, a device driver for the video class handles the I/O for the device. Which device driver should be used cannot be determined until the USB device is connected.</P
><P
>In this case, the driver request event for the USB connection and the event function for each device driver are used in order to map a class driver to the USB device. Specifically, when the USB bus driver (USB manager) monitoring the USB ports detects a newly connected USB device, it sends the driver request event for the USB connection (<TT
CLASS="literal"
>TDV_USBEVT</TT
>) to each device driver which will be candidate of the class driver and then calls the event function for each device.</P
><P
>The event function for each device returns whether or not it can support the newly connected USB device in response to this <TT
CLASS="literal"
>TDV_USBEVT</TT
>. The USB bus driver receives the return codes and determines the mapping to the actual class driver.</P
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="device_event_notification_device_management"
>Device Event Notification</A
></H3
><P
>A device driver sends events that occur on each device to the specific message buffer (event notification message buffer) as device event notification messages. The event notification message buffer ID is referenced or set as an attribute data of <TT
CLASS="literal"
>TDN_EVENT</TT
> for each device.</P
><P
>The system default event notification message buffer is used immediately after device registration. As a device is registered by <A
HREF="device_management_functions.html#tk_def_dev"
>tk_def_dev</A
> when a device driver is started, the system default event notification message buffer ID value is returned as this API's return parameter, the value is held in the device driver and is used as the initial value of this attribute data, <TT
CLASS="literal"
>TDN_EVENT</TT
>.</P
><P
>The system default event notification message buffer is created at system startup. Its size and maximum message length are defined by <TT
CLASS="literal"
>TDEvtMbfSz</TT
> in the system configuration information.</P
><P
>The message formats used in device event notification are as follows: The content and size of the event notification message vary depending on the event type.</P
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
>◇Basic format of device event notification</DT
><DD
><PRE
CLASS="programlisting"
>&#13;typedef struct t_devevt {
        TDEvtTyp        evttyp;         /* event type */
        /* Information specific to each event type is appended here. */
} T_DEVEVT;
</PRE
></DD
><DT
>◇Format of device event notification with device ID</DT
><DD
><PRE
CLASS="programlisting"
>&#13;typedef struct t_devevt_id {
        TDEvtTyp        evttyp;         /* event type */
        ID              devid;          /* Device ID */
        /* Information specific to each event type is appended here. */
} T_DEVEVT_ID;
</PRE
></DD
><DT
>◇Format of device event notification with extended information</DT
><DD
><PRE
CLASS="programlisting"
>&#13;typedef struct t_devevt_ex {
        TDEvtTyp        evttyp;         /* event type */
        ID              devid;          /* Device ID */
        UB              exdat[16];      /* Extended information */
        /* Information specific to each event type is appended here. */
} T_DEVEVT_EX;
</PRE
></DD
></DL
></DIV
><P
>The event type of a device event notification is classified as follows:</P
><P
></P
><OL
TYPE="a"
><LI
><P
>Basic event notification (event type: 0x0001 to 0x002F)</P
><P
>Basic event notification from a device</P
></LI
><LI
><P
>System event notification (event type: 0x0030 to 0x007F)</P
><P
>Event notification related to entire system such as power supply control</P
></LI
><LI
><P
>Event notification with extended information (event type: 0x0080 to 0x00FF)</P
><P
>Event notification from a device with extended information</P
></LI
><LI
><P
>User-defined event notification (event type: 0x0100 to 0xFFFF)</P
><P
>Notification of event that users can arbitrarily define</P
></LI
></OL
><P
>Typical event types are as follows:
<PRE
CLASS="programlisting"
>&#13;typedef enum tdevttyp {
        TDE_unknown     = 0,            /* undefined */
        TDE_MOUNT       = 0x01,         /* media insert */
        TDE_EJECT       = 0x02,         /* Eject media */
        TDE_POWEROFF    = 0x31,         /* power switch off */
        TDE_POWERLOW    = 0x32,         /* low power alarm */
        TDE_POWERFAIL   = 0x33,         /* abnormal power */
        TDE_POWERSUS    = 0x34          /* auto suspend */
} TDEvtTyp;
</PRE
>
</P
><P
>Measures must be taken so that if event notification cannot be sent because the message buffer is full, the lack of notification will not adversely affect operation on the receiving end. One option is to hold the notification until space becomes available in the message buffer, but in that case other device driver processing should not, as a rule, be allowed to fall behind as a result. Processing on the receiving end should be designed to avoid message buffer overflow as much as possible.</P
></DIV
><DIV
CLASS="section"
><H3
CLASS="section"
><A
NAME="device_suspend_resume_processing_device_management"
>Device Suspend/Resume Processing</A
></H3
><P
>Device drivers perform suspend and resume operations in response to the issuing of suspend/resume events (<TT
CLASS="literal"
>TDV_SUSPEND</TT
>/<TT
CLASS="literal"
>TDV_RESUME</TT
>) to the event handling function (<A
HREF="device_management_functions.html#eventfn"
>eventfn</A
>). Suspend and resume events are issued only to physical devices.</P
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="device_suspend_processing"
>Device suspend processing</A
></H4
><P
>The event for starting suspend processing is as follows:</P
><PRE
CLASS="synopsis"
>&#13;evttyp = TDV_SUSPEND
evtinf = NULL (none)
</PRE
><P
>By issuing suspend event (<TT
CLASS="literal"
>TDV_SUSPEND</TT
>), suspend processing takes place as follows.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>If there is a request being processed at the time, the device driver waits for it to complete, pauses it or aborts it. Which of these options to take depends on the device driver implementation. Since the suspension must be effected as quickly as possible, however, pause or abort should be chosen if completion of the request will take time.</P
><P
>Suspend events can be issued only for physical devices, but the same processing is applied to all logical devices included in the physical device.</P
><P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
>Pause: Processing is suspended, then continues after the device resumes operation.</TD
></TR
><TR
><TD
>Abort: Processing is aborted just as when the abort function (<A
HREF="device_management_functions.html#abortfn"
>abortfn</A
>) is executed, and is not continued after the device resumes operation.</TD
></TR
></TBODY
></TABLE
><P
></P
></LI
><LI
><P
>New requests other than a resume event are not accepted.</P
></LI
><LI
><P
>The device power is cut off and other suspend operation is performed.</P
></LI
></OL
><P
>Abort should be avoided if possible because of its effects on applications. It should be used only in such cases as long input wait from a serial port, or when pause would be difficult. Normally it is best to wait for completion of a request or, if possible, choose pause (suspend and resume).</P
><P
>Requests arriving at the device driver in suspend state are made to wait until operation resumes, after which they are accepted for processing. If the request does not involve access to the device, however, or otherwise can be processed even during suspension, a request may be accepted without waiting for resumption.</P
></DIV
><DIV
CLASS="section"
><H4
CLASS="section"
><A
NAME="device_resume_processing"
>Device resume processing</A
></H4
><P
>The event for starting resume processing is as follows:</P
><PRE
CLASS="synopsis"
>&#13;evttyp = TDV_RESUME
evtinf = NULL (none)
</PRE
><P
>By issuing resume event (<TT
CLASS="literal"
>TDV_RESUME</TT
>), resume processing takes place as follows.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The device power is turned back on, the device states are restored and other device resume processing is performed.</P
></LI
><LI
><P
>Paused processing is resumed.</P
></LI
><LI
><P
>Accepting request is resumed.</P
></LI
></OL
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="utk_sm_functions.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="interrupt_management_functions_sm.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>μT-Kernel/SM Functions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="utk_sm_functions.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Interrupt Management Functions</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>